{
  "codeDataMap": {
    "0": {
      "funcName": "",
      "parentContract": "0xb0720d8541cd2b6fc35ccc39ec84e84383a7000b",
      "parentId": -1
    },
    "1": {
      "funcName": "",
      "parentContract": "0x486da49a56b564b824ea140fa4a5ff74de6cf34b",
      "parentId": 0
    },
    "100": {
      "funcName": "Transfer",
      "parentContract": "0x713630359cc9046869ad1642a7b61c23956425cc",
      "parentId": 89
    },
    "101": {
      "funcName": "0xd6b1dd38",
      "parentContract": "0x713630359cc9046869ad1642a7b61c23956425cc",
      "parentId": 89
    },
    "102": {
      "funcName": "NotificationAttempt",
      "parentContract": "0x713630359cc9046869ad1642a7b61c23956425cc",
      "parentId": 89
    },
    "103": {
      "funcName": "ContractNotified",
      "parentContract": "0x713630359cc9046869ad1642a7b61c23956425cc",
      "parentId": 89
    },
    "104": {
      "funcName": "balanceOf",
      "parentContract": "0x10ed43c718714eb63d5aa57b78b54704e256024e",
      "parentId": 88
    },
    "106": {
      "funcName": "getReserves",
      "parentContract": "0x10ed43c718714eb63d5aa57b78b54704e256024e",
      "parentId": 88
    },
    "108": {
      "funcName": "balanceOf",
      "parentContract": "0x10ed43c718714eb63d5aa57b78b54704e256024e",
      "parentId": 88
    },
    "110": {
      "funcName": "swap",
      "parentContract": "0x10ed43c718714eb63d5aa57b78b54704e256024e",
      "parentId": 88
    },
    "116": {
      "funcName": "transfer",
      "parentContract": "0xaae35c003a323d291b7293618506aa612302b7cf",
      "parentId": 110
    },
    "121": {
      "funcName": "Transfer",
      "parentContract": "0xd3c304697f63b279cd314f92c19cdbe5e5b1631a",
      "parentId": 116
    },
    "122": {
      "funcName": "balanceOf",
      "parentContract": "0xaae35c003a323d291b7293618506aa612302b7cf",
      "parentId": 110
    },
    "124": {
      "funcName": "balanceOf",
      "parentContract": "0xaae35c003a323d291b7293618506aa612302b7cf",
      "parentId": 110
    },
    "13": {
      "funcName": "swap",
      "parentContract": "0x1e70f17d4e9db9341af7fc6a8ffcdcb2a52291e5",
      "parentId": 6
    },
    "138": {
      "funcName": "Sync",
      "parentContract": "0xaae35c003a323d291b7293618506aa612302b7cf",
      "parentId": 110
    },
    "139": {
      "funcName": "Swap",
      "parentContract": "0xaae35c003a323d291b7293618506aa612302b7cf",
      "parentId": 110
    },
    "141": {
      "funcName": "balanceOf",
      "parentContract": "0x10ed43c718714eb63d5aa57b78b54704e256024e",
      "parentId": 88
    },
    "144": {
      "funcName": "sync",
      "parentContract": "0x91334d03dd9b9de8d48b50fe389337eeb759aeb1",
      "parentId": 84
    },
    "148": {
      "funcName": "balanceOf",
      "parentContract": "0x12dabfce08ef59c24cdee6c488e05179fb8d64d9",
      "parentId": 144
    },
    "151": {
      "funcName": "balanceOf",
      "parentContract": "0x12dabfce08ef59c24cdee6c488e05179fb8d64d9",
      "parentId": 144
    },
    "160": {
      "funcName": "Sync",
      "parentContract": "0x12dabfce08ef59c24cdee6c488e05179fb8d64d9",
      "parentId": 144
    },
    "164": {
      "funcName": "transfer",
      "parentContract": "0x91334d03dd9b9de8d48b50fe389337eeb759aeb1",
      "parentId": 84
    },
    "176": {
      "funcName": "Transfer",
      "parentContract": "0x713630359cc9046869ad1642a7b61c23956425cc",
      "parentId": 164
    },
    "177": {
      "funcName": "0xd6b1dd38",
      "parentContract": "0x713630359cc9046869ad1642a7b61c23956425cc",
      "parentId": 164
    },
    "179": {
      "funcName": "0xd6b1dd38",
      "parentContract": "0x6278fa23fbe28b9736214e03cf2030f5ee1ccac9",
      "parentId": 177
    },
    "181": {
      "funcName": "NotificationAttempt",
      "parentContract": "0x713630359cc9046869ad1642a7b61c23956425cc",
      "parentId": 164
    },
    "182": {
      "funcName": "ContractNotified",
      "parentContract": "0x713630359cc9046869ad1642a7b61c23956425cc",
      "parentId": 164
    },
    "183": {
      "funcName": "balanceOf",
      "parentContract": "0x1e70f17d4e9db9341af7fc6a8ffcdcb2a52291e5",
      "parentId": 25
    },
    "186": {
      "funcName": "swapTokensForExactTokens",
      "parentContract": "0x1e70f17d4e9db9341af7fc6a8ffcdcb2a52291e5",
      "parentId": 25
    },
    "187": {
      "funcName": "getReserves",
      "parentContract": "0x10ed43c718714eb63d5aa57b78b54704e256024e",
      "parentId": 186
    },
    "189": {
      "funcName": "transferFrom",
      "parentContract": "0x10ed43c718714eb63d5aa57b78b54704e256024e",
      "parentId": 186
    },
    "19": {
      "funcName": "transfer",
      "parentContract": "0xe3cba5c0a8efaedce84751af2efddcf071d311a9",
      "parentId": 13
    },
    "196": {
      "funcName": "Transfer",
      "parentContract": "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
      "parentId": 189
    },
    "197": {
      "funcName": "swap",
      "parentContract": "0x10ed43c718714eb63d5aa57b78b54704e256024e",
      "parentId": 186
    },
    "203": {
      "funcName": "transfer",
      "parentContract": "0x12dabfce08ef59c24cdee6c488e05179fb8d64d9",
      "parentId": 197
    },
    "208": {
      "funcName": "Transfer",
      "parentContract": "0xd3c304697f63b279cd314f92c19cdbe5e5b1631a",
      "parentId": 203
    },
    "209": {
      "funcName": "balanceOf",
      "parentContract": "0x12dabfce08ef59c24cdee6c488e05179fb8d64d9",
      "parentId": 197
    },
    "211": {
      "funcName": "balanceOf",
      "parentContract": "0x12dabfce08ef59c24cdee6c488e05179fb8d64d9",
      "parentId": 197
    },
    "220": {
      "funcName": "Sync",
      "parentContract": "0x12dabfce08ef59c24cdee6c488e05179fb8d64d9",
      "parentId": 197
    },
    "221": {
      "funcName": "Swap",
      "parentContract": "0x12dabfce08ef59c24cdee6c488e05179fb8d64d9",
      "parentId": 197
    },
    "224": {
      "funcName": "transfer",
      "parentContract": "0x1e70f17d4e9db9341af7fc6a8ffcdcb2a52291e5",
      "parentId": 25
    },
    "229": {
      "funcName": "Transfer",
      "parentContract": "0xd3c304697f63b279cd314f92c19cdbe5e5b1631a",
      "parentId": 224
    },
    "230": {
      "funcName": "balanceOf",
      "parentContract": "0x1e70f17d4e9db9341af7fc6a8ffcdcb2a52291e5",
      "parentId": 25
    },
    "232": {
      "funcName": "transfer",
      "parentContract": "0x1e70f17d4e9db9341af7fc6a8ffcdcb2a52291e5",
      "parentId": 25
    },
    "237": {
      "funcName": "Transfer",
      "parentContract": "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
      "parentId": 232
    },
    "238": {
      "funcName": "balanceOf",
      "parentContract": "0xe3cba5c0a8efaedce84751af2efddcf071d311a9",
      "parentId": 13
    },
    "24": {
      "funcName": "Transfer",
      "parentContract": "0xd3c304697f63b279cd314f92c19cdbe5e5b1631a",
      "parentId": 19
    },
    "240": {
      "funcName": "balanceOf",
      "parentContract": "0xe3cba5c0a8efaedce84751af2efddcf071d311a9",
      "parentId": 13
    },
    "25": {
      "funcName": "pancakeCall",
      "parentContract": "0xe3cba5c0a8efaedce84751af2efddcf071d311a9",
      "parentId": 13
    },
    "254": {
      "funcName": "Sync",
      "parentContract": "0xe3cba5c0a8efaedce84751af2efddcf071d311a9",
      "parentId": 13
    },
    "255": {
      "funcName": "Swap",
      "parentContract": "0xe3cba5c0a8efaedce84751af2efddcf071d311a9",
      "parentId": 13
    },
    "26": {
      "funcName": "approve",
      "parentContract": "0x1e70f17d4e9db9341af7fc6a8ffcdcb2a52291e5",
      "parentId": 25
    },
    "29": {
      "funcName": "Approval",
      "parentContract": "0xd3c304697f63b279cd314f92c19cdbe5e5b1631a",
      "parentId": 26
    },
    "30": {
      "funcName": "approve",
      "parentContract": "0x1e70f17d4e9db9341af7fc6a8ffcdcb2a52291e5",
      "parentId": 25
    },
    "32": {
      "funcName": "Approval",
      "parentContract": "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
      "parentId": 30
    },
    "33": {
      "funcName": "balanceOf",
      "parentContract": "0x1e70f17d4e9db9341af7fc6a8ffcdcb2a52291e5",
      "parentId": 25
    },
    "35": {
      "funcName": "swapExactTokensForTokensSupportingFeeOnTransferTokens",
      "parentContract": "0x1e70f17d4e9db9341af7fc6a8ffcdcb2a52291e5",
      "parentId": 25
    },
    "36": {
      "funcName": "transferFrom",
      "parentContract": "0x10ed43c718714eb63d5aa57b78b54704e256024e",
      "parentId": 35
    },
    "42": {
      "funcName": "Transfer",
      "parentContract": "0xd3c304697f63b279cd314f92c19cdbe5e5b1631a",
      "parentId": 36
    },
    "43": {
      "funcName": "balanceOf",
      "parentContract": "0x10ed43c718714eb63d5aa57b78b54704e256024e",
      "parentId": 35
    },
    "45": {
      "funcName": "getReserves",
      "parentContract": "0x10ed43c718714eb63d5aa57b78b54704e256024e",
      "parentId": 35
    },
    "47": {
      "funcName": "balanceOf",
      "parentContract": "0x10ed43c718714eb63d5aa57b78b54704e256024e",
      "parentId": 35
    },
    "49": {
      "funcName": "swap",
      "parentContract": "0x10ed43c718714eb63d5aa57b78b54704e256024e",
      "parentId": 35
    },
    "55": {
      "funcName": "transfer",
      "parentContract": "0x12dabfce08ef59c24cdee6c488e05179fb8d64d9",
      "parentId": 49
    },
    "6": {
      "funcName": "_attack",
      "parentContract": "0x486da49a56b564b824ea140fa4a5ff74de6cf34b",
      "parentId": 0
    },
    "60": {
      "funcName": "Transfer",
      "parentContract": "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
      "parentId": 55
    },
    "61": {
      "funcName": "balanceOf",
      "parentContract": "0x12dabfce08ef59c24cdee6c488e05179fb8d64d9",
      "parentId": 49
    },
    "63": {
      "funcName": "balanceOf",
      "parentContract": "0x12dabfce08ef59c24cdee6c488e05179fb8d64d9",
      "parentId": 49
    },
    "77": {
      "funcName": "Sync",
      "parentContract": "0x12dabfce08ef59c24cdee6c488e05179fb8d64d9",
      "parentId": 49
    },
    "78": {
      "funcName": "Swap",
      "parentContract": "0x12dabfce08ef59c24cdee6c488e05179fb8d64d9",
      "parentId": 49
    },
    "8": {
      "funcName": "balanceOf",
      "parentContract": "0x1e70f17d4e9db9341af7fc6a8ffcdcb2a52291e5",
      "parentId": 6
    },
    "80": {
      "funcName": "balanceOf",
      "parentContract": "0x10ed43c718714eb63d5aa57b78b54704e256024e",
      "parentId": 35
    },
    "82": {
      "funcName": "balanceOf",
      "parentContract": "0x1e70f17d4e9db9341af7fc6a8ffcdcb2a52291e5",
      "parentId": 25
    },
    "84": {
      "funcName": "releaseReward",
      "parentContract": "0x1e70f17d4e9db9341af7fc6a8ffcdcb2a52291e5",
      "parentId": 25
    },
    "88": {
      "funcName": "swapExactTokensForTokensSupportingFeeOnTransferTokens",
      "parentContract": "0x91334d03dd9b9de8d48b50fe389337eeb759aeb1",
      "parentId": 84
    },
    "89": {
      "funcName": "transferFrom",
      "parentContract": "0x10ed43c718714eb63d5aa57b78b54704e256024e",
      "parentId": 88
    }
  },
  "codeFilesMap": {
    "0x21842597390c4c6e3c1239e434a682b054bd9548eee5e9b1d6a4482731023c0f": [
      {
        "code": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./base/ModuleManager.sol\";\nimport \"./base/OwnerManager.sol\";\nimport \"./base/FallbackManager.sol\";\nimport \"./base/GuardManager.sol\";\nimport \"./common/EtherPaymentFallback.sol\";\nimport \"./common/Singleton.sol\";\nimport \"./common/SignatureDecoder.sol\";\nimport \"./common/SecuredTokenTransfer.sol\";\nimport \"./common/StorageAccessible.sol\";\nimport \"./interfaces/ISignatureValidator.sol\";\nimport \"./external/GnosisSafeMath.sol\";\n\n/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract GnosisSafe is\n    EtherPaymentFallback,\n    Singleton,\n    ModuleManager,\n    OwnerManager,\n    SignatureDecoder,\n    SecuredTokenTransfer,\n    ISignatureValidatorConstants,\n    FallbackManager,\n    StorageAccessible,\n    GuardManager\n{\n    using GnosisSafeMath for uint256;\n\n    string public constant VERSION = \"1.3.0\";\n\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // keccak256(\n    //     \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);\n    event ApproveHash(bytes32 indexed approvedHash, address indexed owner);\n    event SignMsg(bytes32 indexed msgHash);\n    event ExecutionFailure(bytes32 txHash, uint256 payment);\n    event ExecutionSuccess(bytes32 txHash, uint256 payment);\n\n    uint256 public nonce;\n    bytes32 private _deprecatedDomainSeparator;\n    // Mapping to keep track of all message hashes that have been approve by ALL REQUIRED owners\n    mapping(bytes32 => uint256) public signedMessages;\n    // Mapping to keep track of all hashes (message or transaction) that have been approve by ANY owners\n    mapping(address => mapping(bytes32 => uint256)) public approvedHashes;\n\n    // This constructor ensures that this contract can only be used as a master copy for Proxy contracts\n    constructor() {\n        // By setting the threshold it is not possible to call setup anymore,\n        // so we create a Safe with 0 owners and threshold 1.\n        // This is an unusable Safe, perfect for the singleton\n        threshold = 1;\n    }\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _owners List of Safe owners.\n    /// @param _threshold Number of required confirmations for a Safe transaction.\n    /// @param to Contract address for optional delegate call.\n    /// @param data Data payload for optional delegate call.\n    /// @param fallbackHandler Handler for fallback calls to this contract\n    /// @param paymentToken Token that should be used for the payment (0 is ETH)\n    /// @param payment Value that should be paid\n    /// @param paymentReceiver Adddress that should receive the payment (or 0 if tx.origin)\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external {\n        // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice\n        setupOwners(_owners, _threshold);\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n        setupModules(to, data);\n\n        if (payment > 0) {\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n        }\n        emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler);\n    }\n\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    ///      Note: The fees are always transferred, even if the user transaction fails.\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @param safeTxGas Gas that should be used for the Safe transaction.\n    /// @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Gas price that should be used for the payment calculation.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) public payable virtual returns (bool success) {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData =\n                encodeTransactionData(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    nonce\n                );\n            // Increase nonce and execute transaction.\n            nonce++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures);\n        }\n        address guard = getGuard();\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkTransaction(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    signatures,\n                    msg.sender\n                );\n            }\n        }\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500, \"GS010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas\n            success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || safeTxGas != 0 || gasPrice != 0, \"GS013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkAfterExecution(txHash, success);\n            }\n        }\n    }\n\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    ) private returns (uint256 payment) {\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            require(receiver.send(payment), \"GS011\");\n        } else {\n            payment = gasUsed.add(baseGas).mul(gasPrice);\n            require(transferToken(gasToken, receiver, payment), \"GS012\");\n        }\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    ) public view {\n        // Load threshold to avoid multiple storage loads\n        uint256 _threshold = threshold;\n        // Check that a threshold is set\n        require(_threshold > 0, \"GS001\");\n        checkNSignatures(dataHash, data, signatures, _threshold);\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     * @param requiredSignatures Amount of required valid signatures.\n     */\n    function checkNSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures,\n        uint256 requiredSignatures\n    ) public view {\n        // Check that the provided signature data is not too short\n        require(signatures.length >= requiredSignatures.mul(65), \"GS020\");\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < requiredSignatures; i++) {\n            (v, r, s) = signatureSplit(signatures, i);\n            if (v == 0) {\n                // If v is 0 then it is a contract signature\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= requiredSignatures.mul(65), \"GS021\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s).add(32) <= signatures.length, \"GS022\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"GS023\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"GS024\");\n            } else if (v == 1) {\n                // If v is 1 then it is an approved hash\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"GS025\");\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            } else {\n                // Default is the ecrecover flow with the provided data hash\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n            require(currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS, \"GS026\");\n            lastOwner = currentOwner;\n        }\n    }\n\n    /// @dev Allows to estimate a Safe transaction.\n    ///      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n    /// @notice Deprecated in favor of common/StorageAccessible.sol and will be removed in next version.\n    function requiredTxGas(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (uint256) {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n     * @dev Marks a hash as approved. This can be used to validate a hash that is used by a signature.\n     * @param hashToApprove The hash that should be marked as approved for signatures that are verified by this contract.\n     */\n    function approveHash(bytes32 hashToApprove) external {\n        require(owners[msg.sender] != address(0), \"GS030\");\n        approvedHashes[msg.sender][hashToApprove] = 1;\n        emit ApproveHash(hashToApprove, msg.sender);\n    }\n\n    /// @dev Returns the chain id used by this contract.\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n    }\n\n    /// @dev Returns the bytes that are hashed to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Gas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash bytes.\n    function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash =\n            keccak256(\n                abi.encode(\n                    SAFE_TX_TYPEHASH,\n                    to,\n                    value,\n                    keccak256(data),\n                    operation,\n                    safeTxGas,\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    _nonce\n                )\n            );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    /// @dev Returns hash to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));\n    }\n}\n",
        "fileIndex": 0,
        "fileName": "GnosisSafe.sol",
        "id": 0,
        "path": "contracts/GnosisSafe.sol"
      },
      {
        "code": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./GnosisSafe.sol\";\n\n/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract GnosisSafeL2 is GnosisSafe {\n    event SafeMultiSigTransaction(\n        address to,\n        uint256 value,\n        bytes data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes signatures,\n        // We combine nonce, sender and threshold into one to avoid stack too deep\n        // Dev note: additionalInfo should not contain `bytes`, as this complicates decoding\n        bytes additionalInfo\n    );\n\n    event SafeModuleTransaction(address module, address to, uint256 value, bytes data, Enum.Operation operation);\n\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    ///      Note: The fees are always transferred, even if the user transaction fails.\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @param safeTxGas Gas that should be used for the Safe transaction.\n    /// @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Gas price that should be used for the payment calculation.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) public payable override returns (bool) {\n        bytes memory additionalInfo;\n        {\n            additionalInfo = abi.encode(nonce, msg.sender, threshold);\n        }\n        emit SafeMultiSigTransaction(\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver,\n            signatures,\n            additionalInfo\n        );\n        return super.execTransaction(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, signatures);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public override returns (bool success) {\n        emit SafeModuleTransaction(msg.sender, to, value, data, operation);\n        success = super.execTransactionFromModule(to, value, data, operation);\n    }\n}\n",
        "fileIndex": 1,
        "fileName": "GnosisSafeL2.sol",
        "id": 1,
        "path": "contracts/GnosisSafeL2.sol"
      },
      {
        "code": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/Enum.sol\";\n\n/// @title Executor - A contract that can execute transactions\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Executor {\n    function execute(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 txGas\n    ) internal returns (bool success) {\n        if (operation == Enum.Operation.DelegateCall) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n            }\n        } else {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n            }\n        }\n    }\n}\n",
        "fileIndex": 2,
        "fileName": "Executor.sol",
        "id": 2,
        "path": "contracts/base/Executor.sol"
      },
      {
        "code": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../common/SelfAuthorized.sol\";\n\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract FallbackManager is SelfAuthorized {\n    event ChangedFallbackHandler(address handler);\n\n    // keccak256(\"fallback_manager.handler.address\")\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\n\n    function internalSetFallbackHandler(address handler) internal {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, handler)\n        }\n    }\n\n    /// @dev Allows to add a contract to handle fallback calls.\n    ///      Only fallback calls without value and with data will be forwarded.\n    ///      This can only be done via a Safe transaction.\n    /// @param handler contract to handle fallbacks calls.\n    function setFallbackHandler(address handler) public authorized {\n        internalSetFallbackHandler(handler);\n        emit ChangedFallbackHandler(handler);\n    }\n\n    // solhint-disable-next-line payable-fallback,no-complex-fallback\n    fallback() external {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let handler := sload(slot)\n            if iszero(handler) {\n                return(0, 0)\n            }\n            calldatacopy(0, 0, calldatasize())\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n            // Then the address without padding is stored right after the calldata\n            mstore(calldatasize(), shl(96, caller()))\n            // Add 20 bytes for the address appended add the end\n            let success := call(gas(), handler, 0, 0, add(calldatasize(), 20), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if iszero(success) {\n                revert(0, returndatasize())\n            }\n            return(0, returndatasize())\n        }\n    }\n}\n",
        "fileIndex": 3,
        "fileName": "FallbackManager.sol",
        "id": 3,
        "path": "contracts/base/FallbackManager.sol"
      },
      {
        "code": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../common/Enum.sol\";\nimport \"../common/SelfAuthorized.sol\";\n\ninterface Guard {\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address msgSender\n    ) external;\n\n    function checkAfterExecution(bytes32 txHash, bool success) external;\n}\n\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract GuardManager is SelfAuthorized {\n    event ChangedGuard(address guard);\n    // keccak256(\"guard_manager.guard.address\")\n    bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    /// @dev Set a guard that checks transactions before execution\n    /// @param guard The address of the guard to be used or the 0 address to disable the guard\n    function setGuard(address guard) external authorized {\n        bytes32 slot = GUARD_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, guard)\n        }\n        emit ChangedGuard(guard);\n    }\n\n    function getGuard() internal view returns (address guard) {\n        bytes32 slot = GUARD_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            guard := sload(slot)\n        }\n    }\n}\n",
        "fileIndex": 4,
        "fileName": "GuardManager.sol",
        "id": 4,
        "path": "contracts/base/GuardManager.sol"
      },
      {
        "code": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/Enum.sol\";\nimport \"../common/SelfAuthorized.sol\";\nimport \"./Executor.sol\";\n\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract ModuleManager is SelfAuthorized, Executor {\n    event EnabledModule(address module);\n    event DisabledModule(address module);\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n\n    address internal constant SENTINEL_MODULES = address(0x1);\n\n    mapping(address => address) internal modules;\n\n    function setupModules(address to, bytes memory data) internal {\n        require(modules[SENTINEL_MODULES] == address(0), \"GS100\");\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0))\n            // Setup has to complete successfully or transaction fails.\n            require(execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()), \"GS000\");\n    }\n\n    /// @dev Allows to add a module to the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Enables the module `module` for the Safe.\n    /// @param module Module to be whitelisted.\n    function enableModule(address module) public authorized {\n        // Module address cannot be null or sentinel.\n        require(module != address(0) && module != SENTINEL_MODULES, \"GS101\");\n        // Module cannot be added twice.\n        require(modules[module] == address(0), \"GS102\");\n        modules[module] = modules[SENTINEL_MODULES];\n        modules[SENTINEL_MODULES] = module;\n        emit EnabledModule(module);\n    }\n\n    /// @dev Allows to remove a module from the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Disables the module `module` for the Safe.\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\n    /// @param module Module to be removed.\n    function disableModule(address prevModule, address module) public authorized {\n        // Validate module address and check that it corresponds to module index.\n        require(module != address(0) && module != SENTINEL_MODULES, \"GS101\");\n        require(modules[prevModule] == module, \"GS103\");\n        modules[prevModule] = modules[module];\n        modules[module] = address(0);\n        emit DisabledModule(module);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public virtual returns (bool success) {\n        // Only whitelisted modules are allowed.\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"GS104\");\n        // Execute transaction without further confirmations.\n        success = execute(to, value, data, operation, gasleft());\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public returns (bool success, bytes memory returnData) {\n        success = execTransactionFromModule(to, value, data, operation);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n    }\n\n    /// @dev Returns if an module is enabled\n    /// @return True if the module is enabled\n    function isModuleEnabled(address module) public view returns (bool) {\n        return SENTINEL_MODULES != module && modules[module] != address(0);\n    }\n\n    /// @dev Returns array of modules.\n    /// @param start Start of the page.\n    /// @param pageSize Maximum number of modules that should be returned.\n    /// @return array Array of modules.\n    /// @return next Start of the next page.\n    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next) {\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount = 0;\n        address currentModule = modules[start];\n        while (currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\n            array[moduleCount] = currentModule;\n            currentModule = modules[currentModule];\n            moduleCount++;\n        }\n        next = currentModule;\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(array, moduleCount)\n        }\n    }\n}\n",
        "fileIndex": 5,
        "fileName": "ModuleManager.sol",
        "id": 5,
        "path": "contracts/base/ModuleManager.sol"
      },
      {
        "code": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/SelfAuthorized.sol\";\n\n/// @title OwnerManager - Manages a set of owners and a threshold to perform actions.\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract OwnerManager is SelfAuthorized {\n    event AddedOwner(address owner);\n    event RemovedOwner(address owner);\n    event ChangedThreshold(uint256 threshold);\n\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    mapping(address => address) internal owners;\n    uint256 internal ownerCount;\n    uint256 internal threshold;\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _owners List of Safe owners.\n    /// @param _threshold Number of required confirmations for a Safe transaction.\n    function setupOwners(address[] memory _owners, uint256 _threshold) internal {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        require(threshold == 0, \"GS200\");\n        // Validate that threshold is smaller than number of added owners.\n        require(_threshold <= _owners.length, \"GS201\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"GS202\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this) && currentOwner != owner, \"GS203\");\n            // No duplicate owners allowed.\n            require(owners[owner] == address(0), \"GS204\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }\n\n    /// @dev Allows to add a new owner to the Safe and update the threshold at the same time.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Adds the owner `owner` to the Safe and updates the threshold to `_threshold`.\n    /// @param owner New owner address.\n    /// @param _threshold New threshold.\n    function addOwnerWithThreshold(address owner, uint256 _threshold) public authorized {\n        // Owner address cannot be null, the sentinel or the Safe itself.\n        require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this), \"GS203\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"GS204\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`.\n    /// @param prevOwner Owner that pointed to the owner to be removed in the linked list\n    /// @param owner Owner address to be removed.\n    /// @param _threshold New threshold.\n    function removeOwner(\n        address prevOwner,\n        address owner,\n        uint256 _threshold\n    ) public authorized {\n        // Only allow to remove an owner, if threshold can still be reached.\n        require(ownerCount - 1 >= _threshold, \"GS201\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"GS203\");\n        require(owners[prevOwner] == owner, \"GS205\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to swap/replace an owner from the Safe with another address.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Replaces the owner `oldOwner` in the Safe with `newOwner`.\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\n    /// @param oldOwner Owner address to be replaced.\n    /// @param newOwner New owner address.\n    function swapOwner(\n        address prevOwner,\n        address oldOwner,\n        address newOwner\n    ) public authorized {\n        // Owner address cannot be null, the sentinel or the Safe itself.\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS && newOwner != address(this), \"GS203\");\n        // No duplicate owners allowed.\n        require(owners[newOwner] == address(0), \"GS204\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"GS203\");\n        require(owners[prevOwner] == oldOwner, \"GS205\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }\n\n    /// @dev Allows to update the number of required confirmations by Safe owners.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Changes the threshold of the Safe to `_threshold`.\n    /// @param _threshold New threshold.\n    function changeThreshold(uint256 _threshold) public authorized {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"GS201\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"GS202\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }\n\n    function getThreshold() public view returns (uint256) {\n        return threshold;\n    }\n\n    function isOwner(address owner) public view returns (bool) {\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\n    }\n\n    /// @dev Returns array of owners.\n    /// @return Array of Safe owners.\n    function getOwners() public view returns (address[] memory) {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while (currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index++;\n        }\n        return array;\n    }\n}\n",
        "fileIndex": 6,
        "fileName": "OwnerManager.sol",
        "id": 6,
        "path": "contracts/base/OwnerManager.sol"
      },
      {
        "code": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Enum - Collection of enums\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Enum {\n    enum Operation {Call, DelegateCall}\n}\n",
        "fileIndex": 7,
        "fileName": "Enum.sol",
        "id": 7,
        "path": "contracts/common/Enum.sol"
      },
      {
        "code": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title EtherPaymentFallback - A contract that has a fallback to accept ether payments\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract EtherPaymentFallback {\n    event SafeReceived(address indexed sender, uint256 value);\n\n    /// @dev Fallback function accepts Ether transactions.\n    receive() external payable {\n        emit SafeReceived(msg.sender, msg.value);\n    }\n}\n",
        "fileIndex": 8,
        "fileName": "EtherPaymentFallback.sol",
        "id": 8,
        "path": "contracts/common/EtherPaymentFallback.sol"
      },
      {
        "code": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SecuredTokenTransfer - Secure token transfer\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SecuredTokenTransfer {\n    /// @dev Transfers a token and returns if it was a success\n    /// @param token Token that should be transferred\n    /// @param receiver Receiver to whom the token should be transferred\n    /// @param amount The amount of tokens that should be transferred\n    function transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal returns (bool transferred) {\n        // 0xa9059cbb - keccack(\"transfer(address,uint256)\")\n        bytes memory data = abi.encodeWithSelector(0xa9059cbb, receiver, amount);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We write the return value to scratch space.\n            // See https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory\n            let success := call(sub(gas(), 10000), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            switch returndatasize()\n                case 0 {\n                    transferred := success\n                }\n                case 0x20 {\n                    transferred := iszero(or(iszero(success), iszero(mload(0))))\n                }\n                default {\n                    transferred := 0\n                }\n        }\n    }\n}\n",
        "fileIndex": 9,
        "fileName": "SecuredTokenTransfer.sol",
        "id": 10,
        "path": "contracts/common/SecuredTokenTransfer.sol"
      },
      {
        "code": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SelfAuthorized - authorizes current contract to perform actions\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SelfAuthorized {\n    function requireSelfCall() private view {\n        require(msg.sender == address(this), \"GS031\");\n    }\n\n    modifier authorized() {\n        // This is a function call as it minimized the bytecode size\n        requireSelfCall();\n        _;\n    }\n}\n",
        "fileIndex": 10,
        "fileName": "SelfAuthorized.sol",
        "id": 11,
        "path": "contracts/common/SelfAuthorized.sol"
      },
      {
        "code": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SignatureDecoder - Decodes signatures that a encoded as bytes\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SignatureDecoder {\n    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.\n    /// @notice Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures\n    /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access\n    /// @param signatures concatenated rsv signatures\n    function signatureSplit(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            // Here we are loading the last 32 bytes, including 31 bytes\n            // of 's'. There is no 'mload8' to do this.\n            //\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n        }\n    }\n}\n",
        "fileIndex": 11,
        "fileName": "SignatureDecoder.sol",
        "id": 12,
        "path": "contracts/common/SignatureDecoder.sol"
      },
      {
        "code": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Singleton - Base for singleton contracts (should always be first super contract)\n///         This contract is tightly coupled to our proxy contract (see `proxies/GnosisSafeProxy.sol`)\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract Singleton {\n    // singleton always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\n    // It should also always be ensured that the address is stored alone (uses a full word)\n    address private singleton;\n}\n",
        "fileIndex": 12,
        "fileName": "Singleton.sol",
        "id": 13,
        "path": "contracts/common/Singleton.sol"
      },
      {
        "code": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title StorageAccessible - generic base contract that allows callers to access all internal storage.\n/// @notice See https://github.com/gnosis/util-contracts/blob/bb5fe5fb5df6d8400998094fb1b32a178a47c3a1/contracts/StorageAccessible.sol\ncontract StorageAccessible {\n    /**\n     * @dev Reads `length` bytes of storage in the currents contract\n     * @param offset - the offset in the current contract's storage in words to start reading from\n     * @param length - the number of words (32 bytes) of data to read\n     * @return the bytes that were read.\n     */\n    function getStorageAt(uint256 offset, uint256 length) public view returns (bytes memory) {\n        bytes memory result = new bytes(length * 32);\n        for (uint256 index = 0; index < length; index++) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let word := sload(add(offset, index))\n                mstore(add(add(result, 0x20), mul(index, 0x20)), word)\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Performs a delegetecall on a targetContract in the context of self.\n     * Internally reverts execution to avoid side effects (making it static).\n     *\n     * This method reverts with data equal to `abi.encode(bool(success), bytes(response))`.\n     * Specifically, the `returndata` after a call to this method will be:\n     * `success:bool || response.length:uint256 || response:bytes`.\n     *\n     * @param targetContract Address of the contract containing the code to execute.\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\n     */\n    function simulateAndRevert(address targetContract, bytes memory calldataPayload) external {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let success := delegatecall(gas(), targetContract, add(calldataPayload, 0x20), mload(calldataPayload), 0, 0)\n\n            mstore(0x00, success)\n            mstore(0x20, returndatasize())\n            returndatacopy(0x40, 0, returndatasize())\n            revert(0, add(returndatasize(), 0x40))\n        }\n    }\n}\n",
        "fileIndex": 13,
        "fileName": "StorageAccessible.sol",
        "id": 14,
        "path": "contracts/common/StorageAccessible.sol"
      },
      {
        "code": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title GnosisSafeMath\n * @dev Math operations with safety checks that revert on error\n * Renamed from SafeMath to GnosisSafeMath to avoid conflicts\n * TODO: remove once open zeppelin update to solc 0.5.0\n */\nlibrary GnosisSafeMath {\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n}\n",
        "fileIndex": 14,
        "fileName": "GnosisSafeMath.sol",
        "id": 15,
        "path": "contracts/external/GnosisSafeMath.sol"
      },
      {
        "code": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\ncontract ISignatureValidatorConstants {\n    // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;\n}\n\nabstract contract ISignatureValidator is ISignatureValidatorConstants {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param _data Arbitrary length data signed on the behalf of address(this)\n     * @param _signature Signature byte array associated with _data\n     *\n     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */\n    function isValidSignature(bytes memory _data, bytes memory _signature) public view virtual returns (bytes4);\n}\n",
        "fileIndex": 15,
        "fileName": "ISignatureValidator.sol",
        "id": 9,
        "path": "contracts/interfaces/ISignatureValidator.sol"
      }
    ],
    "0x4654d519bb3a67b062c0c4ddf0e2623a2d7cbddde0a8460503dd0b4bc995f8a1": [
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n",
        "fileIndex": 0,
        "fileName": "Ownable.sol",
        "id": 21,
        "path": "@openzeppelin/contracts/access/Ownable.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n",
        "fileIndex": 1,
        "fileName": "ReentrancyGuard.sol",
        "id": 22,
        "path": "@openzeppelin/contracts/security/ReentrancyGuard.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n",
        "fileIndex": 2,
        "fileName": "ERC20.sol",
        "id": 23,
        "path": "@openzeppelin/contracts/token/ERC20/ERC20.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n",
        "fileIndex": 3,
        "fileName": "IERC20Metadata.sol",
        "id": 24,
        "path": "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n",
        "fileIndex": 4,
        "fileName": "IERC20Permit.sol",
        "id": 25,
        "path": "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n",
        "fileIndex": 5,
        "fileName": "IERC20.sol",
        "id": 26,
        "path": "@openzeppelin/contracts/token/ERC20/IERC20.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n",
        "fileIndex": 6,
        "fileName": "SafeERC20.sol",
        "id": 27,
        "path": "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n",
        "fileIndex": 7,
        "fileName": "Address.sol",
        "id": 28,
        "path": "@openzeppelin/contracts/utils/Address.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n",
        "fileIndex": 8,
        "fileName": "Context.sol",
        "id": 29,
        "path": "@openzeppelin/contracts/utils/Context.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n",
        "fileIndex": 9,
        "fileName": "SafeMath.sol",
        "id": 30,
        "path": "@openzeppelin/contracts/utils/math/SafeMath.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\nimport {IPancakePair} from \"./IPancakePair.sol\";\nimport {IUniswapV2Factory} from \"./IUniswapV2Factory.sol\";\nimport {IPancakeRouter02} from \"./IPancakeRouter02.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {_GPC, _ROUTER,_WBNB,_USDC,_USDT} from \"./Const.sol\";\n\n\ncontract Distributor {\n    constructor() {\n        IERC20(_GPC).approve(msg.sender, type(uint256).max);\n    }\n}\n\nabstract contract BaseGpc {\n    bool public inSwapAndLiquify;\n    IPancakeRouter02 constant uniswapV2Router = IPancakeRouter02(_ROUTER);\n    address public immutable uniswapV2Pair;\n    Distributor public immutable distributor;\n    mapping(address=>bool) pairs;\n\n\n    modifier lockTheSwap() {\n        require(inSwapAndLiquify != true, 'Cannot Reenter Swap');\n        inSwapAndLiquify = true;\n        _;\n        inSwapAndLiquify = false;\n    }\n    constructor() {\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), _GPC);\n        distributor = new Distributor();\n        pairs[uniswapV2Pair]=true;\n        address bnbPair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), _WBNB);\n        address usdcPair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), _USDC);\n        address usdtPair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), _USDT);\n        pairs[bnbPair]=true;\n        pairs[usdcPair]=true;\n        pairs[usdtPair]=true;\n    }\n\n    function isPair(address account) public view returns (bool) {\n        return pairs[account];\n    }\n\n    function isMainPair(address pair) public view returns (bool){\n        return pair==uniswapV2Pair;\n    }\n}",
        "fileIndex": 10,
        "fileName": "BaseGpc.sol",
        "id": 31,
        "path": "contracts/BaseGpc.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\naddress constant _GPC = 0xD3c304697f63B279cd314F92c19cDBE5E5b1631A;\naddress constant _ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\naddress constant DEAD_WALLET = 0x000000000000000000000000000000000000dEaD;\naddress constant _WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\naddress constant _USDC = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;\naddress constant _USDT = 0x55d398326f99059fF775485246999027B3197955;\n",
        "fileIndex": 11,
        "fileName": "Const.sol",
        "id": 32,
        "path": "contracts/Const.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nabstract contract ExcludedFromFeeList is Ownable {\n    mapping(address => bool) internal _isExcludedFromFee;\n\n    event ExcludedFromFee(address account);\n    event IncludedToFee(address account);\n\n    function isExcludedFromFee(address account) public view returns (bool) {\n        return _isExcludedFromFee[account];\n    }\n\n    function excludeFromFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = true;\n        emit ExcludedFromFee(account);\n    }\n\n    function includeInFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = false;\n        emit IncludedToFee(account);\n    }\n\n    function excludeMultipleAccountsFromFee(address[] calldata accounts) public onlyOwner {\n        uint256 len = uint256(accounts.length);\n        for (uint256 i = 0; i < len;) {\n            _isExcludedFromFee[accounts[i]] = true;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}",
        "fileIndex": 12,
        "fileName": "ExcludedFromFeeList.sol",
        "id": 33,
        "path": "contracts/ExcludedFromFeeList.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nlibrary Helper {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        uint256 amountInWithFee = amountIn * 9975;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = (reserveIn * 10000) + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * 9975;\n        amountIn = (numerator / denominator) + 1;\n    }\n}",
        "fileIndex": 13,
        "fileName": "Helper.sol",
        "id": 34,
        "path": "contracts/Helper.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\ninterface IPancakePair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}",
        "fileIndex": 14,
        "fileName": "IPancakePair.sol",
        "id": 35,
        "path": "contracts/IPancakePair.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\ninterface IPancakeRouter01 {\r\n    \r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n\r\n}",
        "fileIndex": 15,
        "fileName": "IPancakeRouter01.sol",
        "id": 36,
        "path": "contracts/IPancakeRouter01.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\nimport \"./IPancakeRouter01.sol\";\r\n\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}",
        "fileIndex": 16,
        "fileName": "IPancakeRouter02.sol",
        "id": 37,
        "path": "contracts/IPancakeRouter02.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n// \n\ninterface ITokenReceiver {\n    /**\n     * @dev \n     * @param sender \n     * @param amount \n     * @return \n     */\n    function onTokenReceived(address sender,address to, uint256 amount) external returns (bytes4);\n}",
        "fileIndex": 17,
        "fileName": "ITokenReceiver.sol",
        "id": 38,
        "path": "contracts/ITokenReceiver.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}",
        "fileIndex": 18,
        "fileName": "IUniswapV2Factory.sol",
        "id": 39,
        "path": "contracts/IUniswapV2Factory.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {IPancakePair} from \"./IPancakePair.sol\";\nimport {IUniswapV2Factory} from \"./IUniswapV2Factory.sol\";\nimport {IPancakeRouter02} from \"./IPancakeRouter02.sol\";\nimport {Helper} from \"./Helper.sol\";\nimport {BaseGpc} from \"./BaseGpc.sol\";\nimport {DEAD_WALLET,_GPC,_ROUTER} from './Const.sol';\nimport \"./ExcludedFromFeeList.sol\";\nimport \"./ITokenReceiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n\ncontract XDK is ExcludedFromFeeList,BaseGpc,ReentrancyGuard,ERC20{\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    // =========================  =========================\n    // \n    uint256 public constant BURN_FEE_RATE = 10; // 1% \n    uint256 public constant BLACK_HOLE_FEE_RATE = 10; // 1% LP\n    uint256 public constant REWARD_FEE_RATE = 10; // 1% \n    uint256 public constant TOTAL_TRADE_FEE = 30; // 3% \n    uint256 public constant SELL_RECYCLE_RATE = 100; // 10%\n    uint256 public constant MAX_RECYCLE_RATE = 100; //10%\n\n    // \n    uint256 public constant REWARD_MIN_HOLD_PECENT = 10; // 1%\n\n    // =========================  =========================\n\n    mapping(address => bool) public isStop; // \n\n    uint40 public immutable recycleColdTime = 1 days; // \n    uint256 public pendingFees; // \n    uint256 public immutable maxBurnFee; // \n\n    // \n    address[] public shareholders; // LP\n    mapping(address=>uint256) lpAmounts;\n    address internal lastUser;\n    mapping(address => bool) private isShareholder;\n    mapping (address => uint256) lpIndex;\n\n    uint256 public currentRewardIndex; // \n    uint256 public rewardPoolBalance; // \n    uint256 public lastRecycleTime; // \n    uint256 public thisRecycleMaxBalance; // \n    uint256 public thisRecycleBalance;\n\n\n    uint256 public immutable _rewardGas = 1000000;\n\n    // \n    uint40 public launchedAtTimestamp;   // \n    bool public isStart;    //\n\n    IERC20 internal immutable gpc;\n\n\n\n    // =========================  =========================\n    event LaunchCompleted(uint256 timestamp);\n\n    event UserPermit(address user,bool status);\n  \n    event TradeFeesDistributed(\n        address indexed sender,\n        address indexed recipient,\n        uint256 burnAmount,\n        uint256 blackHoleAmount,\n        uint256 rewardAmount\n    );\n    event SellRecycledFromBlackHole(\n        uint256 sellAmount,\n        uint256 recycleAmount,\n        bool success\n    );\n    event LpOperationFeeDeducted(\n        address indexed user,\n        bool isAddLp,\n        uint256 feeAmount\n    );\n    event RewardsDistributed(\n        uint256 batchIndex,\n        uint256 processedCount,\n        uint256 totalDistributed,\n        uint256 remainingBalance\n    );\n    event ShareholderAdded(address indexed shareholder);\n\n    event ContractNotified(\n        address indexed sender,\n        address indexed reciever,\n        uint256 amount,\n        bool success\n    );\n\n    event ErrorMessage(string message);\n\n\n    // =========================  =========================\n    constructor(\n        string memory Name,\n        string memory Symbol,\n        uint256 TotalSupply,\n        uint256 _maxBurnFee,\n        address reciveAddress\n    ) ERC20(Name, Symbol) {\n        // \n        maxBurnFee = _maxBurnFee * 10 ** decimals();\n        // \n        excludeFromFee(address(0));\n        excludeFromFee(DEAD_WALLET);\n        excludeFromFee(address(this));\n        excludeFromFee(reciveAddress);\n        updateShareholder(reciveAddress);\n        _mint(reciveAddress, TotalSupply * 10 ** decimals());\n        gpc = IERC20(_GPC);\n        _approve(reciveAddress, _ROUTER,  type(uint256).max);\n        _approve(address(this), _ROUTER,  type(uint256).max);   \n        gpc.approve(_ROUTER, type(uint256).max);\n        \n    }\n\n \n\n\n    // =========================  =========================\n    function launch() public onlyOwner {\n        require(!isStart, \"Already launched\");\n        launchedAtTimestamp = uint40(block.timestamp);\n        isStart = true;\n      \n        emit LaunchCompleted(launchedAtTimestamp);\n    }\n\n\n    function setAddressFreeze(address account, bool status) external onlyOwner{\n        isStop[account] = status;   \n        emit UserPermit(account,status);\n    }\n\n\n    // ========================= ++ =========================\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal override  {\n        // \n        require(\n            sender != address(0) && recipient != address(0),\n            \"Zero address\"\n        );\n        require(amount > 0, \"Zero amount\");\n        require(!isStop[sender] && !isStop[recipient], \"Address stopped\");\n       \n        address pairAddress = uniswapV2Pair;\n\n        // \n        if (\n            _isExcludedFromFee[sender] ||\n            _isExcludedFromFee[recipient] || inSwapAndLiquify\n        ) {\n            super._transfer(sender, recipient, amount);\n            _afterTokenTransferSelf(sender,recipient,amount);\n            return;\n        }\n        \n        //uint256 transferAmount = amount;\n         bool isBuy = false;\n        bool isSell = false;\n        address user = address(0); // \n\n        // 1. LP\n        if (isPair(recipient)) {\n            isSell = true;\n            user = sender;\n            pairAddress = recipient;\n        } else if (isPair(sender)) {\n            isBuy = true;\n            user = recipient;\n            pairAddress = sender;\n        }\n        if (isBuy || isSell) {\n           \n            handlerTranscation(sender,recipient,amount,user,isSell);\n          \n        }else{\n            // \n            super._transfer(sender, recipient, amount);\n            _afterTokenTransferSelf(sender,recipient,amount);\n            return;\n        }\n   \n    }\n\n    function handlerTranscation(address sender,\n        address recipient,\n        uint256 transferAmount,address user,bool isSell) internal {\n        uint256 currentBurn = balanceOf(DEAD_WALLET);\n        require(isStart,'not started');\n            // 10%\n            (uint112 reverseThis,)=getReverses();\n            require(transferAmount < reverseThis/10,'max cap');\n            // 3%\n            uint256 totalFee = (transferAmount * TOTAL_TRADE_FEE) / 1000;\n            uint256 burnAmount = 0;\n            if (totalFee > 0) {\n                transferAmount -= totalFee;\n                burnAmount = (totalFee * BURN_FEE_RATE) /\n                    TOTAL_TRADE_FEE;\n                uint256 blackHoleAmount = (totalFee * BLACK_HOLE_FEE_RATE) /\n                    TOTAL_TRADE_FEE;\n                uint256 rewardAmount = totalFee - burnAmount - blackHoleAmount;\n\n                if(currentBurn >=maxBurnFee){\n                    if(burnAmount>0){\n                        blackHoleAmount += burnAmount; \n                        burnAmount=0;\n                    }\n                }else{\n                    if(currentBurn + burnAmount > maxBurnFee){\n                        uint256 remaining = maxBurnFee - currentBurn; // \n                        uint256 toBurn = remaining; // \n                        uint256 excess = burnAmount - toBurn; // \n\n                        if (toBurn > 0) {\n                            super._transfer(sender, DEAD_WALLET, toBurn);\n                        }\n                        if (excess > 0) {\n                            blackHoleAmount += excess; // \n                        }\n                        burnAmount = toBurn; // burnAmount\n                    \n                    }else{\n                        super._transfer(sender, DEAD_WALLET, burnAmount);\n                    }\n                }\n                \n            \n                if (blackHoleAmount > 0) {\n                    // \n                    super._transfer(sender, address(this), blackHoleAmount);\n                    pendingFees += blackHoleAmount;\n\n                }\n                if (rewardAmount > 0) {\n                    super._transfer(sender, address(this), rewardAmount);\n                    rewardPoolBalance += rewardAmount;\n                }\n                emit TradeFeesDistributed(\n                    sender,\n                    recipient,\n                    burnAmount,\n                    blackHoleAmount,\n                    rewardAmount\n                );\n            }\n            // addLPLPLP\n            updateShareholder(user);\n\n            // ====================== isLpAdd =======================\n            if (isSell) {\n                \n                _processPendingFees();\n                \n                if (currentBurn + burnAmount <= maxBurnFee && isMainPair(recipient)) {             \n                    _recycleFromBlackHoleOnSell(transferAmount);\n                }   \n                if (rewardPoolBalance > 0) {\n                    distributeRewardsBatch();\n                }\n            }\n             // ======================  =======================\n            super._transfer(sender, recipient, transferAmount);\n    }\n\n    // =========================  =========================\n    function updateShareholder(address user) internal virtual nonReentrant{\n        if (user == DEAD_WALLET || user == address(0) || user == address(this))\n            return;  \n        // \n      \n        if(user !=address(0)){\n            IERC20 lp = IERC20(uniswapV2Pair);\n            uint256 balance =   lp.balanceOf(lastUser);     \n            if(balance>0){\n                lpAmounts[lastUser] = balance;\n                if(!isShareholder[lastUser]){\n                    isShareholder[lastUser] = true; // 1-based\n                    shareholders.push(lastUser);\n                    lpIndex[lastUser]=shareholders.length-1;\n                    emit ShareholderAdded(lastUser);\n                }\n            }else{\n                if(isShareholder[lastUser]){\n                    delete isShareholder[lastUser];\n                    uint256 index = lpIndex[lastUser];\n                    address latest = shareholders[shareholders.length-1];\n                    shareholders[index]=latest;\n                    lpIndex[latest]=index;\n                    shareholders.pop();\n                    lpIndex[lastUser]=0;\n                }\n            }\n            \n        }\n        lastUser = user;\n\n       \n    }\n\n    event RewardsDistributedSim(address user, uint256 rewardPoolBalance,uint256 reward);\n\n\n    // ========================= LP=========================\n    function distributeRewardsBatch() internal virtual nonReentrant{\n        // \n        require(rewardPoolBalance > 0, \"No rewards available\");\n        IERC20 lp = IERC20(uniswapV2Pair);\n        uint256 totalLpSupply = lp.totalSupply();\n        uint256 deadLp = lp.balanceOf(DEAD_WALLET) + lp.balanceOf(address(0));\n        uint256 totalLp = totalLpSupply - deadLp;\n        uint256 distributableThed= totalLp * REWARD_MIN_HOLD_PECENT / 1000;\n        uint256 shareholderCount = shareholders.length;\n        if (totalLp == 0 || shareholderCount == 0) return;\n\n        // \n        uint256 distributable = rewardPoolBalance;\n        if (distributable == 0) return;\n\n        // Gas\n        uint256 gasUsed = 0;\n        uint256 iterations = 0;\n        uint256 gasLeft = gasleft();\n        uint256 totalDistributed=0;\n\n        while (gasUsed < _rewardGas && iterations < shareholderCount) {\n            if (currentRewardIndex >= shareholderCount) {\n                currentRewardIndex = 0;\n            }\n            address shareholder = shareholders[currentRewardIndex];\n            uint256 userLp = lp.balanceOf(shareholder);\n            if (userLp < distributableThed) {\n                iterations++;\n                currentRewardIndex++; // \n                gasUsed += (gasLeft - gasleft()); // \n                gasLeft = gasleft();\n                continue;\n            }\n            uint256 permit =  lpAmounts[shareholder] * 5 /100;\n\n            if(lpAmounts[shareholder] > userLp || userLp - lpAmounts[shareholder] >= permit){\n                iterations++;\n                currentRewardIndex++; // \n                lpAmounts[shareholder]=userLp;\n                gasUsed += (gasLeft - gasleft()); // \n                gasLeft = gasleft();\n                continue;\n            }\n            uint256 reward = (distributable * lpAmounts[shareholder]) / totalLp;\n            if(lpAmounts[shareholder] !=userLp){\n                lpAmounts[shareholder]=userLp;\n            }\n            if (reward == 0) {\n                currentRewardIndex++;\n                iterations++;\n                \n                gasUsed += (gasLeft - gasleft());\n                gasLeft = gasleft();\n                continue;\n            }\n            // \n            super._transfer(address(this), shareholder, reward);\n            emit RewardsDistributedSim(shareholder,distributable,reward);\n            totalDistributed += reward;\n            iterations++;\n            currentRewardIndex++;\n            gasUsed = gasUsed + (gasLeft - gasleft());\n            gasLeft = gasleft();\n        }\n        // \n        rewardPoolBalance -= totalDistributed;\n        if (currentRewardIndex >= shareholderCount) currentRewardIndex = 0;\n\n        emit RewardsDistributed(\n            currentRewardIndex,\n            iterations,\n            totalDistributed,\n            rewardPoolBalance\n        );\n    }\n\n    // =========================  =========================\n    function _recycleFromBlackHoleOnSell(uint256 sellAmount\n    ) internal virtual  {\n        if (lastRecycleTime + recycleColdTime < block.timestamp) {\n            lastRecycleTime = block.timestamp;\n            thisRecycleMaxBalance =\n                (balanceOf(uniswapV2Pair) * MAX_RECYCLE_RATE) /\n                1000;\n            thisRecycleBalance = 0;\n            return;\n        }\n        if(thisRecycleBalance >=thisRecycleMaxBalance){\n            return;\n        }\n\n        \n        uint256 targetXdk = sellAmount * SELL_RECYCLE_RATE / 1000;\n\n        // 10%\n        // 2. LPLPLPLPXDK\n        IPancakePair lpContract = IPancakePair(uniswapV2Pair);\n        uint256 blackHoleLp = lpContract.balanceOf(DEAD_WALLET); // LP\n        uint256 totalLpSupply = lpContract.totalSupply(); // LP\n        uint256 reserveXdk = balanceOf(uniswapV2Pair); // LPXDK\n\n        // LP0LP\n        if (totalLpSupply == 0 || blackHoleLp == 0 || reserveXdk == 0) {\n            emit SellRecycledFromBlackHole(sellAmount, 0, false);\n            return;\n        }\n        // 3. LPXDK\n        // LPXDK =LP / LP* LPXDK\n        uint256 xdkInBlackHoleLp = (blackHoleLp * reserveXdk) / totalLpSupply;\n\n        // 4.  = min(, LPXDK)\n        uint256 actualRecycleXdk = targetXdk > xdkInBlackHoleLp\n            ? xdkInBlackHoleLp\n            : targetXdk;\n        if (actualRecycleXdk == 0) {\n            emit SellRecycledFromBlackHole(sellAmount, 0, false);\n            return;\n        }\n       \n        // LP\n        uint256 otherLpTotalShrink = (actualRecycleXdk *\n            (reserveXdk - xdkInBlackHoleLp)) / reserveXdk;\n        if (actualRecycleXdk == 0 || otherLpTotalShrink == 0) {\n            emit SellRecycledFromBlackHole(sellAmount, 0, false);\n            return;\n        }\n        thisRecycleBalance =thisRecycleBalance + actualRecycleXdk + otherLpTotalShrink;\n       \n        // 5. LPXDK\n        // LPXDKLPremoveLiquidity\n        bool success = false;\n\n        // LPXDK\n        // LPXDKLP\n        super._transfer(uniswapV2Pair, DEAD_WALLET, actualRecycleXdk);\n        super._transfer(uniswapV2Pair, address(this), otherLpTotalShrink);\n        rewardPoolBalance += otherLpTotalShrink;\n        success = true;\n        lpContract.sync();\n        emit SellRecycledFromBlackHole(\n            sellAmount,\n            actualRecycleXdk,\n            success\n        );\n    }\n\n    // =========================  =========================\n    function _processPendingFees() internal virtual lockTheSwap{\n        // LP\n        if(pendingFees>0){\n            swapAndLiquify(pendingFees);\n            pendingFees = 0;\n        }     \n    }\n\n\n\n    function swapTokenForGPC(uint256 tokenAmount, address to) internal virtual returns(bool){\n        unchecked {\n            address[] memory path = new address[](2);\n             path[0] = address(this);\n            path[1] = _GPC;\n            \n           \n            uniswapV2Router\n                .swapExactTokensForTokensSupportingFeeOnTransferTokens(\n                    tokenAmount,\n                    0, // accept any amount of ETH\n                    path,\n                    to,\n                    block.timestamp+300\n            );\n            return true;\n        }\n    }\n\n\n    function addLiquidity(uint256 tokenAmount, uint256 gpcAmount) internal virtual{\n        uniswapV2Router.addLiquidity(\n            address(this),\n            _GPC,\n            tokenAmount,\n            gpcAmount,\n            0,\n            0,\n            DEAD_WALLET,\n             block.timestamp+300\n        );\n    }\n\n    function swapAndLiquify(uint256 tokens) internal virtual {\n        uint256 half = tokens / 2;\n        uint256 otherHalf = tokens - half;\n        uint256 initialBalance = gpc.balanceOf(address(this));\n        bool result = swapTokenForGPC(half, address(distributor));\n        if(result){\n            gpc.safeTransferFrom(address(distributor),\n                address(this),\n                gpc.balanceOf(address(distributor)));\n            uint256 newBalance = gpc.balanceOf(address(this)) - initialBalance;\n            addLiquidity(otherHalf, newBalance);\n        }\n    }\n\n   function _afterTokenTransferSelf(\n    address from,\n    address to,\n    uint256 amount\n) internal virtual {\n\n    //  try  call call \n   bool isNotificationSuccess = notifyContract(from, to, amount);\n   emit ContractNotified(from, to, amount, isNotificationSuccess);\n   \n}\nevent NotificationAttempt(\n    address indexed receiver,\n    bool isContract,       // codeSize > 0\n    bool isSmartWallet,    // \n    bool callSucceeded     // \n);\n\n\n//  call  try/catch \nfunction notifyContract(address from, address to, uint256 amount) internal returns (bool) {\n     uint256 codeSize;\n    assembly { codeSize := extcodesize(to) }\n    if (codeSize == 0) return true; // \n\n\n    // 4.   callonTokenReceived\n    (bool success, ) = to.call(\n        abi.encodeWithSignature(\"onTokenReceived(address,address,uint256)\", from, to, amount)\n    );\n    // successtrue/falserevert\n    emit NotificationAttempt(to, true, false, success);\n    return success;\n\n}\n\n\n    // =========================  =========================\n    function getRewardPoolBalance() external view returns (uint256) {\n        return rewardPoolBalance;\n    }\n\n    function getBlackHoleLpBalance() external view returns (uint256) {\n        return DEAD_WALLET == address(0) ? 0 : balanceOf(DEAD_WALLET);\n    }\n\n    function getUserLPInfo(address user) external view returns(uint256,uint256,uint256){\n        IERC20 lp = IERC20(uniswapV2Pair);\n        uint256 totalLpSupply = lp.totalSupply();\n        uint256 deadLp = lp.balanceOf(DEAD_WALLET) + lp.balanceOf(address(0));\n        uint256 totalLp = totalLpSupply - deadLp;\n        return (totalLpSupply,totalLp,lp.balanceOf(user));\n    }\n\n    function getPendingFees() external view returns (uint256) {\n        return pendingFees;\n    }\n\n    function getShareholderCount() external view returns (uint256) {\n        return shareholders.length;\n    }\n\n\n    function getReverses() public view returns(uint112, uint112){\n        address token0 = IPancakePair(uniswapV2Pair).token0();\n        //address token1 = IPancakePair(uniswapV2Pair).token1();\n\n        (uint112 reserve0, uint112 reserve1,)=IPancakePair(uniswapV2Pair).getReserves();\n\n        // 2. \n        if(token0==address(this)){\n            return (reserve0,reserve1);\n        }else{\n            return (reserve1,reserve0);\n        }\n    \n    }\n\n\n    \n\n\n}\n",
        "fileIndex": 19,
        "fileName": "XDK.sol",
        "id": 40,
        "path": "contracts/XDK.sol"
      }
    ],
    "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8": [
      {
        "code": "/**\r\n *Submitted for verification at BscScan.com on 2021-04-23\r\n*/\r\n\r\n// File: contracts\\interfaces\\IPancakePair.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IPancakePair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// File: contracts\\interfaces\\IPancakeERC20.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IPancakeERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\n// File: contracts\\libraries\\SafeMath.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n}\r\n\r\n// File: contracts\\PancakeERC20.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\ncontract PancakeERC20 is IPancakeERC20 {\r\n    using SafeMath for uint;\r\n\r\n    string public constant name = 'Pancake LPs';\r\n    string public constant symbol = 'Cake-LP';\r\n    uint8 public constant decimals = 18;\r\n    uint  public totalSupply;\r\n    mapping(address => uint) public balanceOf;\r\n    mapping(address => mapping(address => uint)) public allowance;\r\n\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    mapping(address => uint) public nonces;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    constructor() public {\r\n        uint chainId;\r\n        assembly {\r\n            chainId := chainid\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes('1')),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    function _mint(address to, uint value) internal {\r\n        totalSupply = totalSupply.add(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint value) internal {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint value) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint value) private {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint value) external returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint value) external returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool) {\r\n        if (allowance[from][msg.sender] != uint(-1)) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n        require(deadline >= block.timestamp, 'Pancake: EXPIRED');\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'Pancake: INVALID_SIGNATURE');\r\n        _approve(owner, spender, value);\r\n    }\r\n}\r\n\r\n// File: contracts\\libraries\\Math.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n// a library for performing various math operations\r\n\r\nlibrary Math {\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\libraries\\UQ112x112.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\n\r\n// range: [0, 2**112 - 1]\r\n// resolution: 1 / 2**112\r\n\r\nlibrary UQ112x112 {\r\n    uint224 constant Q112 = 2**112;\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 y) internal pure returns (uint224 z) {\r\n        z = uint224(y) * Q112; // never overflows\r\n    }\r\n\r\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\r\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\r\n        z = x / uint224(y);\r\n    }\r\n}\r\n\r\n// File: contracts\\interfaces\\IERC20.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\n// File: contracts\\interfaces\\IPancakeFactory.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IPancakeFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n// File: contracts\\interfaces\\IPancakeCallee.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IPancakeCallee {\r\n    function pancakeCall(address sender, uint amount0, uint amount1, bytes calldata data) external;\r\n}\r\n\r\n// File: contracts\\PancakePair.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract PancakePair is IPancakePair, PancakeERC20 {\r\n    using SafeMath  for uint;\r\n    using UQ112x112 for uint224;\r\n\r\n    uint public constant MINIMUM_LIQUIDITY = 10**3;\r\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n\r\n    address public factory;\r\n    address public token0;\r\n    address public token1;\r\n\r\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\r\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\r\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\r\n\r\n    uint public price0CumulativeLast;\r\n    uint public price1CumulativeLast;\r\n    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\r\n\r\n    uint private unlocked = 1;\r\n    modifier lock() {\r\n        require(unlocked == 1, 'Pancake: LOCKED');\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\r\n        _reserve0 = reserve0;\r\n        _reserve1 = reserve1;\r\n        _blockTimestampLast = blockTimestampLast;\r\n    }\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Pancake: TRANSFER_FAILED');\r\n    }\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    constructor() public {\r\n        factory = msg.sender;\r\n    }\r\n\r\n    // called once by the factory at time of deployment\r\n    function initialize(address _token0, address _token1) external {\r\n        require(msg.sender == factory, 'Pancake: FORBIDDEN'); // sufficient check\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n    }\r\n\r\n    // update reserves and, on the first call per block, price accumulators\r\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\r\n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'Pancake: OVERFLOW');\r\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\r\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\r\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\r\n            // * never overflows, and + overflow is desired\r\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\r\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\r\n        }\r\n        reserve0 = uint112(balance0);\r\n        reserve1 = uint112(balance1);\r\n        blockTimestampLast = blockTimestamp;\r\n        emit Sync(reserve0, reserve1);\r\n    }\r\n\r\n    // if fee is on, mint liquidity equivalent to 8/25 of the growth in sqrt(k)\r\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\r\n        address feeTo = IPancakeFactory(factory).feeTo();\r\n        feeOn = feeTo != address(0);\r\n        uint _kLast = kLast; // gas savings\r\n        if (feeOn) {\r\n            if (_kLast != 0) {\r\n                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\r\n                uint rootKLast = Math.sqrt(_kLast);\r\n                if (rootK > rootKLast) {\r\n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast)).mul(8);\r\n                    uint denominator = rootK.mul(17).add(rootKLast.mul(8));\r\n                    uint liquidity = numerator / denominator;\r\n                    if (liquidity > 0) _mint(feeTo, liquidity);\r\n                }\r\n            }\r\n        } else if (_kLast != 0) {\r\n            kLast = 0;\r\n        }\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function mint(address to) external lock returns (uint liquidity) {\r\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\r\n        uint balance0 = IERC20(token0).balanceOf(address(this));\r\n        uint balance1 = IERC20(token1).balanceOf(address(this));\r\n        uint amount0 = balance0.sub(_reserve0);\r\n        uint amount1 = balance1.sub(_reserve1);\r\n\r\n        bool feeOn = _mintFee(_reserve0, _reserve1);\r\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\r\n        if (_totalSupply == 0) {\r\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\r\n           _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\r\n        } else {\r\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\r\n        }\r\n        require(liquidity > 0, 'Pancake: INSUFFICIENT_LIQUIDITY_MINTED');\r\n        _mint(to, liquidity);\r\n\r\n        _update(balance0, balance1, _reserve0, _reserve1);\r\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\r\n        emit Mint(msg.sender, amount0, amount1);\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function burn(address to) external lock returns (uint amount0, uint amount1) {\r\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\r\n        address _token0 = token0;                                // gas savings\r\n        address _token1 = token1;                                // gas savings\r\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\r\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\r\n        uint liquidity = balanceOf[address(this)];\r\n\r\n        bool feeOn = _mintFee(_reserve0, _reserve1);\r\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\r\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\r\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\r\n        require(amount0 > 0 && amount1 > 0, 'Pancake: INSUFFICIENT_LIQUIDITY_BURNED');\r\n        _burn(address(this), liquidity);\r\n        _safeTransfer(_token0, to, amount0);\r\n        _safeTransfer(_token1, to, amount1);\r\n        balance0 = IERC20(_token0).balanceOf(address(this));\r\n        balance1 = IERC20(_token1).balanceOf(address(this));\r\n\r\n        _update(balance0, balance1, _reserve0, _reserve1);\r\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\r\n        emit Burn(msg.sender, amount0, amount1, to);\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\r\n        require(amount0Out > 0 || amount1Out > 0, 'Pancake: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\r\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'Pancake: INSUFFICIENT_LIQUIDITY');\r\n\r\n        uint balance0;\r\n        uint balance1;\r\n        { // scope for _token{0,1}, avoids stack too deep errors\r\n        address _token0 = token0;\r\n        address _token1 = token1;\r\n        require(to != _token0 && to != _token1, 'Pancake: INVALID_TO');\r\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\r\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\r\n        if (data.length > 0) IPancakeCallee(to).pancakeCall(msg.sender, amount0Out, amount1Out, data);\r\n        balance0 = IERC20(_token0).balanceOf(address(this));\r\n        balance1 = IERC20(_token1).balanceOf(address(this));\r\n        }\r\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\r\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\r\n        require(amount0In > 0 || amount1In > 0, 'Pancake: INSUFFICIENT_INPUT_AMOUNT');\r\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\r\n        uint balance0Adjusted = (balance0.mul(10000).sub(amount0In.mul(25)));\r\n        uint balance1Adjusted = (balance1.mul(10000).sub(amount1In.mul(25)));\r\n        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(10000**2), 'Pancake: K');\r\n        }\r\n\r\n        _update(balance0, balance1, _reserve0, _reserve1);\r\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\r\n    }\r\n\r\n    // force balances to match reserves\r\n    function skim(address to) external lock {\r\n        address _token0 = token0; // gas savings\r\n        address _token1 = token1; // gas savings\r\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\r\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\r\n    }\r\n\r\n    // force reserves to match balances\r\n    function sync() external lock {\r\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\r\n    }\r\n}",
        "fileIndex": 0,
        "fileName": "PancakePair.sol",
        "id": 16,
        "path": "PancakePair.sol"
      }
    ],
    "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71": [
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n",
        "fileIndex": 0,
        "fileName": "Ownable.sol",
        "id": 56,
        "path": "@openzeppelin/contracts/access/Ownable.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n",
        "fileIndex": 1,
        "fileName": "ReentrancyGuard.sol",
        "id": 57,
        "path": "@openzeppelin/contracts/security/ReentrancyGuard.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n",
        "fileIndex": 2,
        "fileName": "ERC20.sol",
        "id": 58,
        "path": "@openzeppelin/contracts/token/ERC20/ERC20.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n",
        "fileIndex": 3,
        "fileName": "IERC20Metadata.sol",
        "id": 59,
        "path": "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n",
        "fileIndex": 4,
        "fileName": "IERC20Permit.sol",
        "id": 60,
        "path": "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n",
        "fileIndex": 5,
        "fileName": "IERC20.sol",
        "id": 61,
        "path": "@openzeppelin/contracts/token/ERC20/IERC20.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n",
        "fileIndex": 6,
        "fileName": "SafeERC20.sol",
        "id": 62,
        "path": "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n",
        "fileIndex": 7,
        "fileName": "Address.sol",
        "id": 63,
        "path": "@openzeppelin/contracts/utils/Address.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n",
        "fileIndex": 8,
        "fileName": "Context.sol",
        "id": 64,
        "path": "@openzeppelin/contracts/utils/Context.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n",
        "fileIndex": 9,
        "fileName": "SafeMath.sol",
        "id": 65,
        "path": "@openzeppelin/contracts/utils/math/SafeMath.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\nimport {IPancakePair} from \"./IPancakePair.sol\";\nimport {IUniswapV2Factory} from \"./IUniswapV2Factory.sol\";\nimport {IPancakeRouter02} from \"./IPancakeRouter02.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {_GPC, _ROUTER,_WBNB,_USDC,_USDT} from \"./Const.sol\";\n\n\ncontract Distributor {\n    constructor() {\n        IERC20(_GPC).approve(msg.sender, type(uint256).max);\n    }\n}\n\nabstract contract BaseGpc {\n    bool public inSwapAndLiquify;\n\n    uint256 public constant MAX_PRICE_LENGTH = 100;\n   \n\n\n    IPancakeRouter02 constant uniswapV2Router = IPancakeRouter02(_ROUTER);\n    address public immutable uniswapV2Pair;\n    Distributor public immutable distributor;\n    mapping(address=>bool) pairs;\n\n    IPancakePair internal uniswapV2PairGpc;\n    IPancakePair internal uniswapV2PairUsdt;\n\n    // ==========  ==========\n    // 1440124\n    uint256 public constant MAX_CAPACITY = 1440;\n    // \n    uint256 public constant MIN_UPDATE_INTERVAL = 60; // 5\n\n    // ==========  ==========\n    // wei+ uint256\n    struct PricePoint {\n        uint256 price;    // USDT/ETHwei\n        uint256 timestamp;// \n    }\n\n    // Gas\n    PricePoint[ MAX_CAPACITY ] private _priceQueue;\n    uint256 private _head;    // \n    uint256 private _tail;    // \n    uint256 private _count;   // \n    uint256 private _lastUpdateTime; // \n\n\n\n    modifier lockTheSwap() {\n        require(inSwapAndLiquify != true, 'Cannot Reenter Swap');\n        inSwapAndLiquify = true;\n        _;\n        inSwapAndLiquify = false;\n    }\n    constructor() {\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), _GPC);\n        distributor = new Distributor();\n        pairs[uniswapV2Pair]=true;\n        address bnbPair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), _WBNB);\n        address usdcPair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), _USDC);\n        address usdtPair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), _USDT);\n        pairs[bnbPair]=true;\n        pairs[usdcPair]=true;\n        pairs[usdtPair]=true;\n\n\n        uniswapV2PairGpc = IPancakePair(\n            IUniswapV2Factory(uniswapV2Router.factory()).getPair(\n                _GPC,\n                uniswapV2Router.WETH()\n            )\n        );\n        uniswapV2PairUsdt = IPancakePair(\n            IUniswapV2Factory(uniswapV2Router.factory()).getPair(\n                _USDT,\n                uniswapV2Router.WETH()\n            )\n        );\n\n    }\n\n    function isPair(address account) public view returns (bool) {\n        return pairs[account];\n    }\n\n    function isMainPair(address pair) public view returns (bool){\n        return pair==uniswapV2Pair;\n    }\n\n\n\n    function getGpcReserves() internal view returns (uint256, uint256, uint256, uint256) {\n        (uint256 _gpcBnbAmount, uint256 _gpcAmount, ) = uniswapV2PairGpc.getReserves();\n        (uint256 _usdtAmount, uint256 _usdtBnbAmount, ) = uniswapV2PairUsdt.getReserves();\n        return (_gpcBnbAmount, _gpcAmount, _usdtAmount, _usdtBnbAmount);\n    }\n\n    function gpcPrice() public view returns (uint256) {\n        (uint256 _gpcBnbAmount, uint256 _gpcAmount, uint256 _usdtAmount, uint256 _usdtBnbAmount) = getGpcReserves();\n        if (_gpcAmount == 0 || _usdtBnbAmount == 0) return 0;\n        \n        uint256 numerator = _gpcBnbAmount*_usdtAmount*1e18;\n        uint256 denominator = _gpcAmount*_usdtBnbAmount;\n        return numerator/denominator;\n    }\n\n    function genMscPrice() public {\n        if(block.timestamp - _lastUpdateTime <= MIN_UPDATE_INTERVAL){\n            return;\n        }\n        uint256 newPrice = mscPriceInner();\n        // 3. \n        _priceQueue[ _tail ] = PricePoint({\n            price: newPrice,\n            timestamp: block.timestamp\n        });\n\n        // 4. \n        _tail = (_tail + 1) % MAX_CAPACITY;\n\n        // 5. \n        if (_count == MAX_CAPACITY) {\n            _head = (_head + 1) % MAX_CAPACITY;\n        } else {\n            // \n            _count += 1;\n        }\n\n        // 6. \n        _lastUpdateTime = block.timestamp;\n        \n    }\n\n    function mscPriceInner() internal view returns(uint256){\n        IPancakePair pair=IPancakePair(uniswapV2Pair);\n        address tokenA = pair.token0();\n        uint256 gpcAmount;\n        uint256 mscAmount;\n        (uint256 amountA, uint256 amountB, ) = pair.getReserves();\n        if(tokenA==_GPC){\n            gpcAmount = amountA;\n            mscAmount = amountB;\n        }else{\n            gpcAmount = amountB;\n            mscAmount = amountA;\n        }\n        if(gpcAmount==0){\n            return 0;\n        }\n        if(mscAmount ==0){\n            return 0;\n        }\n        uint256 price = gpcAmount*gpcPrice()/mscAmount;\n        return price;\n    }\n\n    /**\n     * @dev TWAP\n     * @param duration 3600=1\n     * @return twap wei\n     */\n  /**\n * @dev TWAP- \n * @param duration 3600=1\n * @return twap wei\n */\nfunction calculateTWAP(uint256 duration) internal view returns (uint256 twap) {\n    // ========== 1.  ==========\n    if (_count == 0 || duration == 0) return 0;\n\n    uint256 endTime = block.timestamp;\n    uint256 startTime = endTime > duration ? endTime - duration : 0;\n\n    // head=tail=\n    uint256 totalWeightedPrice; // \n    uint256 totalWeight;        // \n    uint256 currentIdx = _head; // \n\n    // ========== 2.  < startTime  ==========\n    //  < startTime \n    while (currentIdx != _tail && _priceQueue[currentIdx].timestamp < startTime) {\n        currentIdx = (currentIdx + 1) % MAX_CAPACITY;\n    }\n\n    // ========== 3.  [startTime, endTime]  ==========\n    // \n    uint256 prevTimestamp = startTime;\n    //  +  <= endTime\n    while (currentIdx != _tail && _priceQueue[currentIdx].timestamp <= endTime) {\n        PricePoint storage point = _priceQueue[currentIdx];\n        \n        //  - [startTime, endTime]\n        uint256 weight = point.timestamp - prevTimestamp;\n        // 0\n        if (weight > 0) {\n            unchecked {\n                totalWeightedPrice += point.price * weight;\n                totalWeight += weight;\n            }\n        }\n\n        // \n        prevTimestamp = point.timestamp;\n        currentIdx = (currentIdx + 1) % MAX_CAPACITY;\n    }\n\n    // ========== 4. endTime ==========\n    // endTime\n    if (totalWeight > 0 && prevTimestamp < endTime) {\n        uint256 lastWeight = endTime - prevTimestamp;\n        if (lastWeight > 0) {\n            // currentIdx\n            uint256 lastIdx = currentIdx == _head ? (currentIdx + MAX_CAPACITY - 1) % MAX_CAPACITY : currentIdx - 1;\n            unchecked {\n                totalWeightedPrice += _priceQueue[lastIdx].price * lastWeight;\n                totalWeight += lastWeight;\n            }\n        }\n    }\n\n    // ========== 5. TWAP ==========\n    if (totalWeight == 0) {\n        // \n        uint256 latestIdx = _tail == 0 ? MAX_CAPACITY - 1 : _tail - 1;\n        twap = _priceQueue[latestIdx].price;\n    } else {\n        unchecked {\n            twap = totalWeightedPrice / totalWeight;\n        }\n    }\n\n    return twap;\n}\n    \n\n   \n    function  mscPrice() external view returns(uint256){\n        uint256 price= calculateTWAP(24 hours);\n        if(price==0){\n            return mscPriceInner();\n        }\n        return price;\n    }\n\n}",
        "fileIndex": 10,
        "fileName": "BaseGpc.sol",
        "id": 66,
        "path": "contracts/BaseGpc.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\naddress constant _GPC = 0xD3c304697f63B279cd314F92c19cDBE5E5b1631A;\naddress constant _ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\naddress constant DEAD_WALLET = 0x000000000000000000000000000000000000dEaD;\naddress constant _WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\naddress constant _USDC = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;\naddress constant _USDT = 0x55d398326f99059fF775485246999027B3197955;\n",
        "fileIndex": 11,
        "fileName": "Const.sol",
        "id": 67,
        "path": "contracts/Const.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nabstract contract ExcludedFromFeeList is Ownable {\n    mapping(address => bool) internal _isExcludedFromFee;\n\n    event ExcludedFromFee(address account);\n    event IncludedToFee(address account);\n\n    function isExcludedFromFee(address account) public view returns (bool) {\n        return _isExcludedFromFee[account];\n    }\n\n    function excludeFromFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = true;\n        emit ExcludedFromFee(account);\n    }\n\n    function includeInFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = false;\n        emit IncludedToFee(account);\n    }\n\n    function excludeMultipleAccountsFromFee(address[] calldata accounts) public onlyOwner {\n        uint256 len = uint256(accounts.length);\n        for (uint256 i = 0; i < len;) {\n            _isExcludedFromFee[accounts[i]] = true;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}",
        "fileIndex": 12,
        "fileName": "ExcludedFromFeeList.sol",
        "id": 68,
        "path": "contracts/ExcludedFromFeeList.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nlibrary Helper {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        uint256 amountInWithFee = amountIn * 9975;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = (reserveIn * 10000) + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * 9975;\n        amountIn = (numerator / denominator) + 1;\n    }\n}",
        "fileIndex": 13,
        "fileName": "Helper.sol",
        "id": 69,
        "path": "contracts/Helper.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\ninterface IPancakePair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}",
        "fileIndex": 14,
        "fileName": "IPancakePair.sol",
        "id": 70,
        "path": "contracts/IPancakePair.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\ninterface IPancakeRouter01 {\r\n    \r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n\r\n}",
        "fileIndex": 15,
        "fileName": "IPancakeRouter01.sol",
        "id": 71,
        "path": "contracts/IPancakeRouter01.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\nimport \"./IPancakeRouter01.sol\";\r\n\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}",
        "fileIndex": 16,
        "fileName": "IPancakeRouter02.sol",
        "id": 72,
        "path": "contracts/IPancakeRouter02.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}",
        "fileIndex": 17,
        "fileName": "IUniswapV2Factory.sol",
        "id": 73,
        "path": "contracts/IUniswapV2Factory.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {IPancakePair} from \"./IPancakePair.sol\";\nimport {IUniswapV2Factory} from \"./IUniswapV2Factory.sol\";\nimport {IPancakeRouter02} from \"./IPancakeRouter02.sol\";\nimport {Helper} from \"./Helper.sol\";\nimport {BaseGpc} from \"./BaseGpc.sol\";\nimport {DEAD_WALLET, _GPC, _ROUTER} from \"./Const.sol\";\nimport \"./ExcludedFromFeeList.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract MSC is ExcludedFromFeeList, BaseGpc, ReentrancyGuard, ERC20 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // =========================  =========================\n    // \n    uint256 public constant BURN_FEE_RATE = 10; // 1% \n    uint256 public constant BLACK_HOLE_FEE_RATE = 10; // 1% LP\n    uint256 public constant REWARD_FEE_RATE = 10; // 1% \n    uint256 public constant TOTAL_TRADE_FEE = 30; // 3% \n    uint256 public constant SELL_RECYCLE_RATE = 100; // 10%\n    uint256 public constant MAX_RECYCLE_RATE = 100; //10%\n    uint256 public constant BIND_AMOUNT = 1e15; //0.001 \n\n    // =========================  =========================\n\n    mapping(address => bool) public isStop; // \n\n    uint40 public immutable recycleColdTime = 1 days; // \n    uint40 public coldTime = 1 minutes;\n\n    // \n    uint40 public launchedAtTimestamp; // \n    bool public isStart; //\n    uint256 public pendingFees;\n    uint256 public deadFees;\n    uint256 public rewardPoolBalance;\n\n    mapping(address => uint40) public lastBuyTime;\n    mapping(address => uint256) public tOwnedStar;\n\n    IERC20 internal immutable gpc;\n    address public starAddress;\n    address public marketAddress;\n\n    // =========================  =========================\n    event LaunchCompleted(uint256 timestamp);\n\n    event UserPermit(address user, bool status);\n    event BurnExpireAllFailed(address starAddress);\n    event SetPriceFailed(address market);\n    event RemoteFailed(address starAddress);\n\n    event TradeFeesDistributed(\n        address indexed sender,\n        address indexed recipient,\n        uint256 burnAmount,\n        uint256 blackHoleAmount,\n        uint256 rewardAmount\n    );\n    event SellRecycledFromBlackHole(\n        uint256 sellAmount,\n        uint256 recycleAmount,\n        bool success\n    );\n\n    event ContractNotified(\n        address indexed sender,\n        address indexed reciever,\n        uint256 amount,\n        bool success\n    );\n\n    event ErrorMessage(string message);\n    event AddressUpdated(address indexed addr);\n\n    // =========================  =========================\n    constructor(\n        string memory Name,\n        string memory Symbol,\n        uint256 TotalSupply,\n        address reciveAddress\n    ) ERC20(Name, Symbol) {\n        // \n        excludeFromFee(address(0));\n        excludeFromFee(DEAD_WALLET);\n        excludeFromFee(address(this));\n        excludeFromFee(reciveAddress);\n\n        _mint(reciveAddress, TotalSupply * 10 ** decimals());\n        gpc = IERC20(_GPC);\n        _approve(reciveAddress, _ROUTER, type(uint256).max);\n        _approve(address(this), _ROUTER, type(uint256).max);\n        gpc.approve(_ROUTER, type(uint256).max);\n    }\n\n    // =========================  =========================\n    function launch() public onlyOwner {\n        require(!isStart, \"Already launched\");\n        launchedAtTimestamp = uint40(block.timestamp);\n        isStart = true;\n\n        emit LaunchCompleted(launchedAtTimestamp);\n    }\n\n    function setMorningStarAddress(address _starAddress) external onlyOwner {\n        require(_starAddress != address(0), \"Invalid address\");\n        _approve(address(this), _starAddress, type(uint256).max);\n        _approve(_starAddress, _ROUTER, type(uint256).max);\n        excludeFromFee(_starAddress);\n        starAddress = _starAddress;\n        emit AddressUpdated(_starAddress);\n    }\n\n    function setMarketAddress(address _marketAddress) external onlyOwner {\n        require(_marketAddress != address(0), \"Invalid address\");\n        _approve(address(this), _marketAddress, type(uint256).max);\n        _approve(_marketAddress, _ROUTER, type(uint256).max);\n        excludeFromFee(_marketAddress);\n        marketAddress = _marketAddress;\n        emit AddressUpdated(_marketAddress);\n    }\n\n    function setAddressFreeze(address account, bool status) external onlyOwner {\n        isStop[account] = status;\n        emit UserPermit(account, status);\n    }\n\n    // ========================= ++ =========================\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal override {\n        // \n        require(\n            sender != address(0) && recipient != address(0),\n            \"Zero address\"\n        );\n\n        require(!isStop[sender] && !isStop[recipient], \"Address stopped\");\n\n        address pairAddress = uniswapV2Pair;\n        // \n        if (recipient == address(this)) {\n            require(starAddress != address(0), \"star is not inited\");\n            if (amount == 0) {\n                (bool success, bytes memory returnData) = starAddress.call(\n                    abi.encodeWithSignature(\"unstake(address)\", sender)\n                );\n                require(success, _parseRevertReason(returnData));\n            } else {\n                super._transfer(sender, recipient, amount);\n                (bool success, bytes memory returnData) = starAddress.call(\n                    abi.encodeWithSignature(\n                        \"staked(address,uint256)\",\n                        sender,\n                        amount\n                    )\n                );\n                require(success, _parseRevertReason(returnData));\n            }\n            return;\n        }\n        if (amount == 0) {\n            (bool success, bytes memory returnData) = starAddress.call(\n                abi.encodeWithSignature(\n                    \"bindReferral(address,address)\",\n                    recipient,\n                    sender\n                )\n            );\n            // amount0\n            require(success, _parseRevertReason(returnData));\n\n            return;\n        }\n        // \n        if (\n            _isExcludedFromFee[sender] ||\n            _isExcludedFromFee[recipient] ||\n            inSwapAndLiquify\n        ) {\n            if (sender == starAddress && !isPair(recipient)) {\n                tOwnedStar[recipient] += amount;\n            }\n            super._transfer(sender, recipient, amount);\n            _afterTokenTransferSelf(sender, recipient, amount);\n            return;\n        }\n\n        //uint256 transferAmount = amount;\n        bool isBuy = false;\n        bool isSell = false;\n\n        // 1. LP\n        if (isPair(recipient)) {\n            isSell = true;\n            pairAddress = recipient;\n        } else if (isPair(sender)) {\n            isBuy = true;\n\n            pairAddress = sender;\n        }\n        if (isBuy || isSell) {\n            handlerTranscation(sender, recipient, amount, isSell);\n        } else {\n            // \n            super._transfer(sender, recipient, amount);\n\n            _afterTokenTransferSelf(sender, recipient, amount);\n            return;\n        }\n    }\n\n    // Solidity revert\n    function _parseRevertReason(\n        bytes memory returnData\n    ) internal pure returns (string memory) {\n        // 1Gas\n        if (returnData.length == 0)\n            return \"No revert data (Gas insufficient/zero address)\";\n        // 2Solidityrevert\n        if (returnData.length >= 5) {\n            // 4selector\n            bytes memory reasonBytes = new bytes(returnData.length - 4);\n            for (uint256 i = 0; i < reasonBytes.length; i++) {\n                reasonBytes[i] = returnData[i + 4];\n            }\n            // bytesstringpanicSoliditybytesstring\n            return string(reasonBytes);\n        }\n        return \"Unknown error\";\n    }\n\n    function handlerTranscation(\n        address sender,\n        address recipient,\n        uint256 transferAmount,\n        bool isSell\n    ) internal {\n        require(isStart, \"not started\");\n\n        // 10%\n        (uint112 reverseThis, ) = getReverses();\n\n        require(transferAmount < reverseThis / 10, \"max cap\");\n\n        if (!isSell) {\n            lastBuyTime[recipient] = uint40(block.timestamp);\n        } else {\n            require(block.timestamp >= lastBuyTime[sender] + coldTime, \"cold\");\n            uint256 profit = 0;\n            if (sender != tx.origin) {\n                if (tOwnedStar[tx.origin] >= transferAmount) {\n                    unchecked {\n                        tOwnedStar[tx.origin] =\n                            tOwnedStar[tx.origin] -\n                            transferAmount;\n                    }\n                } else if (\n                    tOwnedStar[tx.origin] > 0 &&\n                    tOwnedStar[tx.origin] < transferAmount\n                ) {\n                    profit = transferAmount - tOwnedStar[tx.origin];\n                    tOwnedStar[tx.origin] = 0;\n                } else {\n                    profit = transferAmount;\n                    tOwnedStar[tx.origin] = 0;\n                }\n            } else {\n                if (tOwnedStar[sender] >= transferAmount) {\n                    unchecked {\n                        tOwnedStar[sender] =\n                            tOwnedStar[sender] -\n                            transferAmount;\n                    }\n                } else if (\n                    tOwnedStar[sender] > 0 &&\n                    tOwnedStar[sender] < transferAmount\n                ) {\n                    profit = transferAmount - tOwnedStar[sender];\n                    tOwnedStar[sender] = 0;\n                } else {\n                    profit = transferAmount;\n                    tOwnedStar[sender] = 0;\n                }\n            }\n\n            uint256 profitFee = (profit * 25) / 100;\n\n            if (profitFee > 0) {\n                super._transfer(sender, marketAddress, profitFee);\n                transferAmount = transferAmount - profitFee;\n            }\n        }\n        // 3%\n        uint256 totalFee = (transferAmount * TOTAL_TRADE_FEE) / 1000;\n        if (totalFee > 0) {\n            transferAmount -= totalFee;\n            uint256 burnAmount = (totalFee * BURN_FEE_RATE) / TOTAL_TRADE_FEE;\n            uint256 blackHoleAmount = (totalFee * BLACK_HOLE_FEE_RATE) /\n                TOTAL_TRADE_FEE;\n            uint256 rewardAmount = totalFee - burnAmount - blackHoleAmount;\n\n            if (burnAmount > 0) {\n                super._transfer(sender, address(this), burnAmount);\n                deadFees += burnAmount;\n            }\n\n            if (blackHoleAmount > 0) {\n                // \n                super._transfer(sender, address(this), blackHoleAmount);\n                pendingFees += blackHoleAmount;\n            }\n            if (rewardAmount > 0) {\n                super._transfer(sender, address(this), rewardAmount);\n                rewardPoolBalance += rewardAmount;\n            }\n            emit TradeFeesDistributed(\n                sender,\n                recipient,\n                burnAmount,\n                blackHoleAmount,\n                rewardAmount\n            );\n        }\n        genMscPrice();\n\n        (bool success, ) = starAddress.call(\n            abi.encodeWithSignature(\"burnExpireAll()\")\n        );\n        if (!success) {\n            //  emit /\n            emit BurnExpireAllFailed(starAddress);\n        }\n        (bool success2, ) = marketAddress.call(\n            abi.encodeWithSignature(\"setPrice()\")\n        );\n        if (!success2) {\n            emit SetPriceFailed(marketAddress);\n        }\n\n        // ====================== isLpAdd =======================\n        if (isSell) {\n            _processPendingBurn();\n\n            _processPendingFees();\n            if (rewardPoolBalance > 0 && starAddress != address(0)) {\n                distributeRewardsBatch();\n            }\n        }\n        // ======================  =======================\n        super._transfer(sender, recipient, transferAmount);\n    }\n\n    event RewardsDistributedSim(\n        address user,\n        uint256 rewardPoolBalance,\n        uint256 reward\n    );\n\n    // ========================= LP=========================\n    function distributeRewardsBatch() internal virtual nonReentrant {\n        // \n        require(rewardPoolBalance > 0, \"No rewards available\");\n        super._transfer(address(this), starAddress, rewardPoolBalance);\n        rewardPoolBalance = 0;\n    }\n\n    function _processPendingBurn() internal virtual lockTheSwap {\n        if (deadFees > 0) {\n            swapTokenForGPC(deadFees, DEAD_WALLET);\n            deadFees = 0;\n        }\n    }\n\n    // =========================  =========================\n    function _processPendingFees() internal virtual lockTheSwap {\n        // LP\n        if (pendingFees > 0) {\n            swapAndLiquify(pendingFees);\n            pendingFees = 0;\n        }\n    }\n\n    function swapTokenForGPC(\n        uint256 tokenAmount,\n        address to\n    ) internal virtual returns (bool) {\n        unchecked {\n            address[] memory path = new address[](2);\n            path[0] = address(this);\n            path[1] = _GPC;\n\n            uniswapV2Router\n                .swapExactTokensForTokensSupportingFeeOnTransferTokens(\n                    tokenAmount,\n                    0, // accept any amount of ETH\n                    path,\n                    to,\n                    block.timestamp + 300\n                );\n            return true;\n        }\n    }\n\n    function addLiquidity(\n        uint256 tokenAmount,\n        uint256 gpcAmount\n    ) internal virtual {\n        uniswapV2Router.addLiquidity(\n            address(this),\n            _GPC,\n            tokenAmount,\n            gpcAmount,\n            0,\n            0,\n            DEAD_WALLET,\n            block.timestamp + 300\n        );\n    }\n\n    function swapAndLiquify(uint256 tokens) internal virtual {\n        uint256 half = tokens / 2;\n        uint256 otherHalf = tokens - half;\n        uint256 initialBalance = gpc.balanceOf(address(this));\n        bool result = swapTokenForGPC(half, address(distributor));\n        if (result) {\n            gpc.safeTransferFrom(\n                address(distributor),\n                address(this),\n                gpc.balanceOf(address(distributor))\n            );\n            uint256 newBalance = gpc.balanceOf(address(this)) - initialBalance;\n            addLiquidity(otherHalf, newBalance);\n        }\n    }\n\n    function _afterTokenTransferSelf(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        //  try  call call \n        bool isNotificationSuccess = notifyContract(from, to, amount);\n        emit ContractNotified(from, to, amount, isNotificationSuccess);\n    }\n\n    event NotificationAttempt(\n        address indexed receiver,\n        bool isContract, // codeSize > 0\n        bool isSmartWallet, // \n        bool callSucceeded // \n    );\n\n    //  call  try/catch \n    function notifyContract(\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (bool) {\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(to)\n        }\n        if (codeSize == 0) return true; // \n\n        // 4.   callonTokenReceived\n        (bool success, ) = to.call(\n            abi.encodeWithSignature(\n                \"onTokenReceived(address,address,uint256)\",\n                from,\n                to,\n                amount\n            )\n        );\n        // successtrue/falserevert\n        emit NotificationAttempt(to, true, false, success);\n        return success;\n    }\n\n    // =========================  =========================\n    function getRewardPoolBalance() external view returns (uint256) {\n        return rewardPoolBalance;\n    }\n\n    function getPendingFees() external view returns (uint256) {\n        return pendingFees;\n    }\n\n    function getReverses() public view returns (uint112, uint112) {\n        address token0 = IPancakePair(uniswapV2Pair).token0();\n        //address token1 = IPancakePair(uniswapV2Pair).token1();\n\n        (uint112 reserve0, uint112 reserve1, ) = IPancakePair(uniswapV2Pair)\n            .getReserves();\n\n        // 2. \n        if (token0 == address(this)) {\n            return (reserve0, reserve1);\n        } else {\n            return (reserve1, reserve0);\n        }\n    }\n}\n",
        "fileIndex": 18,
        "fileName": "MSC.sol",
        "id": 74,
        "path": "contracts/MSC.sol"
      }
    ],
    "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e": [
      {
        "code": "// File: @uniswap\\lib\\contracts\\libraries\\TransferHelper.sol\r\n\r\npragma solidity >=0.6.0;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n// File: contracts\\interfaces\\IPancakeRouter01.sol\r\n\r\npragma solidity >=0.6.2;\r\n\r\ninterface IPancakeRouter01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n// File: contracts\\interfaces\\IPancakeRouter02.sol\r\n\r\npragma solidity >=0.6.2;\r\n\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n// File: contracts\\interfaces\\IPancakeFactory.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IPancakeFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n\r\n    function INIT_CODE_PAIR_HASH() external view returns (bytes32);\r\n}\r\n\r\n// File: contracts\\libraries\\SafeMath.sol\r\n\r\npragma solidity =0.6.6;\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n}\r\n\r\n// File: contracts\\interfaces\\IPancakePair.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IPancakePair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// File: contracts\\libraries\\PancakeLibrary.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\n\r\n\r\nlibrary PancakeLibrary {\r\n    using SafeMath for uint;\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'PancakeLibrary: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'PancakeLibrary: ZERO_ADDRESS');\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                factory,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex'00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5' // init code hash\r\n            ))));\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        pairFor(factory, tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = IPancakePair(pairFor(factory, tokenA, tokenB)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n\r\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\r\n        require(amountA > 0, 'PancakeLibrary: INSUFFICIENT_AMOUNT');\r\n        require(reserveA > 0 && reserveB > 0, 'PancakeLibrary: INSUFFICIENT_LIQUIDITY');\r\n        amountB = amountA.mul(reserveB) / reserveA;\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        require(amountIn > 0, 'PancakeLibrary: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'PancakeLibrary: INSUFFICIENT_LIQUIDITY');\r\n        uint amountInWithFee = amountIn.mul(9975);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(10000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\r\n        require(amountOut > 0, 'PancakeLibrary: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'PancakeLibrary: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = reserveIn.mul(amountOut).mul(10000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(9975);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'PancakeLibrary: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\r\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n\r\n    // performs chained getAmountIn calculations on any number of pairs\r\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'PancakeLibrary: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[amounts.length - 1] = amountOut;\r\n        for (uint i = path.length - 1; i > 0; i--) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\r\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\interfaces\\IERC20.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\n// File: contracts\\interfaces\\IWETH.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n\r\n// File: contracts\\PancakeRouter.sol\r\n\r\npragma solidity =0.6.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract PancakeRouter is IPancakeRouter02 {\r\n    using SafeMath for uint;\r\n\r\n    address public immutable override factory;\r\n    address public immutable override WETH;\r\n\r\n    modifier ensure(uint deadline) {\r\n        require(deadline >= block.timestamp, 'PancakeRouter: EXPIRED');\r\n        _;\r\n    }\r\n\r\n    constructor(address _factory, address _WETH) public {\r\n        factory = _factory;\r\n        WETH = _WETH;\r\n    }\r\n\r\n    receive() external payable {\r\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n    // **** ADD LIQUIDITY ****\r\n    function _addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin\r\n    ) internal virtual returns (uint amountA, uint amountB) {\r\n        // create the pair if it doesn't exist yet\r\n        if (IPancakeFactory(factory).getPair(tokenA, tokenB) == address(0)) {\r\n            IPancakeFactory(factory).createPair(tokenA, tokenB);\r\n        }\r\n        (uint reserveA, uint reserveB) = PancakeLibrary.getReserves(factory, tokenA, tokenB);\r\n        if (reserveA == 0 && reserveB == 0) {\r\n            (amountA, amountB) = (amountADesired, amountBDesired);\r\n        } else {\r\n            uint amountBOptimal = PancakeLibrary.quote(amountADesired, reserveA, reserveB);\r\n            if (amountBOptimal <= amountBDesired) {\r\n                require(amountBOptimal >= amountBMin, 'PancakeRouter: INSUFFICIENT_B_AMOUNT');\r\n                (amountA, amountB) = (amountADesired, amountBOptimal);\r\n            } else {\r\n                uint amountAOptimal = PancakeLibrary.quote(amountBDesired, reserveB, reserveA);\r\n                assert(amountAOptimal <= amountADesired);\r\n                require(amountAOptimal >= amountAMin, 'PancakeRouter: INSUFFICIENT_A_AMOUNT');\r\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\r\n            }\r\n        }\r\n    }\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\r\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\r\n        address pair = PancakeLibrary.pairFor(factory, tokenA, tokenB);\r\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\r\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\r\n        liquidity = IPancakePair(pair).mint(to);\r\n    }\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\r\n        (amountToken, amountETH) = _addLiquidity(\r\n            token,\r\n            WETH,\r\n            amountTokenDesired,\r\n            msg.value,\r\n            amountTokenMin,\r\n            amountETHMin\r\n        );\r\n        address pair = PancakeLibrary.pairFor(factory, token, WETH);\r\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\r\n        IWETH(WETH).deposit{value: amountETH}();\r\n        assert(IWETH(WETH).transfer(pair, amountETH));\r\n        liquidity = IPancakePair(pair).mint(to);\r\n        // refund dust eth, if any\r\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\r\n    }\r\n\r\n    // **** REMOVE LIQUIDITY ****\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\r\n        address pair = PancakeLibrary.pairFor(factory, tokenA, tokenB);\r\n        IPancakePair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\r\n        (uint amount0, uint amount1) = IPancakePair(pair).burn(to);\r\n        (address token0,) = PancakeLibrary.sortTokens(tokenA, tokenB);\r\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\r\n        require(amountA >= amountAMin, 'PancakeRouter: INSUFFICIENT_A_AMOUNT');\r\n        require(amountB >= amountBMin, 'PancakeRouter: INSUFFICIENT_B_AMOUNT');\r\n    }\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\r\n        (amountToken, amountETH) = removeLiquidity(\r\n            token,\r\n            WETH,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            address(this),\r\n            deadline\r\n        );\r\n        TransferHelper.safeTransfer(token, to, amountToken);\r\n        IWETH(WETH).withdraw(amountETH);\r\n        TransferHelper.safeTransferETH(to, amountETH);\r\n    }\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external virtual override returns (uint amountA, uint amountB) {\r\n        address pair = PancakeLibrary.pairFor(factory, tokenA, tokenB);\r\n        uint value = approveMax ? uint(-1) : liquidity;\r\n        IPancakePair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\r\n    }\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external virtual override returns (uint amountToken, uint amountETH) {\r\n        address pair = PancakeLibrary.pairFor(factory, token, WETH);\r\n        uint value = approveMax ? uint(-1) : liquidity;\r\n        IPancakePair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\r\n    }\r\n\r\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) public virtual override ensure(deadline) returns (uint amountETH) {\r\n        (, amountETH) = removeLiquidity(\r\n            token,\r\n            WETH,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            address(this),\r\n            deadline\r\n        );\r\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\r\n        IWETH(WETH).withdraw(amountETH);\r\n        TransferHelper.safeTransferETH(to, amountETH);\r\n    }\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external virtual override returns (uint amountETH) {\r\n        address pair = PancakeLibrary.pairFor(factory, token, WETH);\r\n        uint value = approveMax ? uint(-1) : liquidity;\r\n        IPancakePair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\r\n            token, liquidity, amountTokenMin, amountETHMin, to, deadline\r\n        );\r\n    }\r\n\r\n    // **** SWAP ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = PancakeLibrary.sortTokens(input, output);\r\n            uint amountOut = amounts[i + 1];\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\n            address to = i < path.length - 2 ? PancakeLibrary.pairFor(factory, output, path[i + 2]) : _to;\r\n            IPancakePair(PancakeLibrary.pairFor(factory, input, output)).swap(\r\n                amount0Out, amount1Out, to, new bytes(0)\r\n            );\r\n        }\r\n    }\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\r\n        amounts = PancakeLibrary.getAmountsOut(factory, amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, to);\r\n    }\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\r\n        amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);\r\n        require(amounts[0] <= amountInMax, 'PancakeRouter: EXCESSIVE_INPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, to);\r\n    }\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        virtual\r\n        override\r\n        payable\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[0] == WETH, 'PancakeRouter: INVALID_PATH');\r\n        amounts = PancakeLibrary.getAmountsOut(factory, msg.value, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        IWETH(WETH).deposit{value: amounts[0]}();\r\n        assert(IWETH(WETH).transfer(PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]));\r\n        _swap(amounts, path, to);\r\n    }\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[path.length - 1] == WETH, 'PancakeRouter: INVALID_PATH');\r\n        amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);\r\n        require(amounts[0] <= amountInMax, 'PancakeRouter: EXCESSIVE_INPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, address(this));\r\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[path.length - 1] == WETH, 'PancakeRouter: INVALID_PATH');\r\n        amounts = PancakeLibrary.getAmountsOut(factory, amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, address(this));\r\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        virtual\r\n        override\r\n        payable\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[0] == WETH, 'PancakeRouter: INVALID_PATH');\r\n        amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);\r\n        require(amounts[0] <= msg.value, 'PancakeRouter: EXCESSIVE_INPUT_AMOUNT');\r\n        IWETH(WETH).deposit{value: amounts[0]}();\r\n        assert(IWETH(WETH).transfer(PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]));\r\n        _swap(amounts, path, to);\r\n        // refund dust eth, if any\r\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\r\n    }\r\n\r\n    // **** SWAP (supporting fee-on-transfer tokens) ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = PancakeLibrary.sortTokens(input, output);\r\n            IPancakePair pair = IPancakePair(PancakeLibrary.pairFor(factory, input, output));\r\n            uint amountInput;\r\n            uint amountOutput;\r\n            { // scope to avoid stack too deep errors\r\n            (uint reserve0, uint reserve1,) = pair.getReserves();\r\n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n            amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\r\n            amountOutput = PancakeLibrary.getAmountOut(amountInput, reserveInput, reserveOutput);\r\n            }\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\r\n            address to = i < path.length - 2 ? PancakeLibrary.pairFor(factory, output, path[i + 2]) : _to;\r\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\r\n        }\r\n    }\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override ensure(deadline) {\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, PancakeLibrary.pairFor(factory, path[0], path[1]), amountIn\r\n        );\r\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n        _swapSupportingFeeOnTransferTokens(path, to);\r\n        require(\r\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\r\n            'PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT'\r\n        );\r\n    }\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n        payable\r\n        ensure(deadline)\r\n    {\r\n        require(path[0] == WETH, 'PancakeRouter: INVALID_PATH');\r\n        uint amountIn = msg.value;\r\n        IWETH(WETH).deposit{value: amountIn}();\r\n        assert(IWETH(WETH).transfer(PancakeLibrary.pairFor(factory, path[0], path[1]), amountIn));\r\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n        _swapSupportingFeeOnTransferTokens(path, to);\r\n        require(\r\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\r\n            'PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT'\r\n        );\r\n    }\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n    {\r\n        require(path[path.length - 1] == WETH, 'PancakeRouter: INVALID_PATH');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, PancakeLibrary.pairFor(factory, path[0], path[1]), amountIn\r\n        );\r\n        _swapSupportingFeeOnTransferTokens(path, address(this));\r\n        uint amountOut = IERC20(WETH).balanceOf(address(this));\r\n        require(amountOut >= amountOutMin, 'PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        IWETH(WETH).withdraw(amountOut);\r\n        TransferHelper.safeTransferETH(to, amountOut);\r\n    }\r\n\r\n    // **** LIBRARY FUNCTIONS ****\r\n    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {\r\n        return PancakeLibrary.quote(amountA, reserveA, reserveB);\r\n    }\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\r\n        public\r\n        pure\r\n        virtual\r\n        override\r\n        returns (uint amountOut)\r\n    {\r\n        return PancakeLibrary.getAmountOut(amountIn, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\r\n        public\r\n        pure\r\n        virtual\r\n        override\r\n        returns (uint amountIn)\r\n    {\r\n        return PancakeLibrary.getAmountIn(amountOut, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountsOut(uint amountIn, address[] memory path)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint[] memory amounts)\r\n    {\r\n        return PancakeLibrary.getAmountsOut(factory, amountIn, path);\r\n    }\r\n\r\n    function getAmountsIn(uint amountOut, address[] memory path)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint[] memory amounts)\r\n    {\r\n        return PancakeLibrary.getAmountsIn(factory, amountOut, path);\r\n    }\r\n}",
        "fileIndex": 0,
        "fileName": "PancakeRouter.sol",
        "id": 17,
        "path": "PancakeRouter.sol"
      }
    ],
    "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a": [
      {
        "code": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function _contextSuffixLength() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n/**\r\n * @dev Standard ERC20 Errors\r\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\r\n */\r\ninterface IERC20Errors {\r\n    /**\r\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     * @param balance Current balance for the interacting account.\r\n     * @param needed Minimum amount required to perform a transfer.\r\n     */\r\n    error ERC20InsufficientBalance(\r\n        address sender,\r\n        uint256 balance,\r\n        uint256 needed\r\n    );\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     */\r\n    error ERC20InvalidSender(address sender);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\r\n     * @param receiver Address to which tokens are being transferred.\r\n     */\r\n    error ERC20InvalidReceiver(address receiver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `spender`s `allowance`. Used in transfers.\r\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\r\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\r\n     * @param needed Minimum amount required to perform a transfer.\r\n     */\r\n    error ERC20InsufficientAllowance(\r\n        address spender,\r\n        uint256 allowance,\r\n        uint256 needed\r\n    );\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\r\n     * @param approver Address initiating an approval operation.\r\n     */\r\n    error ERC20InvalidApprover(address approver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\r\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\r\n     */\r\n    error ERC20InvalidSpender(address spender);\r\n}\r\n\r\n/**\r\n * @dev Standard ERC721 Errors\r\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\r\n */\r\ninterface IERC721Errors {\r\n    /**\r\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\r\n     * Used in balance queries.\r\n     * @param owner Address of the current owner of a token.\r\n     */\r\n    error ERC721InvalidOwner(address owner);\r\n\r\n    /**\r\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\r\n     * @param tokenId Identifier number of a token.\r\n     */\r\n    error ERC721NonexistentToken(uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     * @param tokenId Identifier number of a token.\r\n     * @param owner Address of the current owner of a token.\r\n     */\r\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     */\r\n    error ERC721InvalidSender(address sender);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\r\n     * @param receiver Address to which tokens are being transferred.\r\n     */\r\n    error ERC721InvalidReceiver(address receiver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\r\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\r\n     * @param tokenId Identifier number of a token.\r\n     */\r\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\r\n     * @param approver Address initiating an approval operation.\r\n     */\r\n    error ERC721InvalidApprover(address approver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\r\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\r\n     */\r\n    error ERC721InvalidOperator(address operator);\r\n}\r\n\r\n/**\r\n * @dev Standard ERC1155 Errors\r\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\r\n */\r\ninterface IERC1155Errors {\r\n    /**\r\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     * @param balance Current balance for the interacting account.\r\n     * @param needed Minimum amount required to perform a transfer.\r\n     * @param tokenId Identifier number of a token.\r\n     */\r\n    error ERC1155InsufficientBalance(\r\n        address sender,\r\n        uint256 balance,\r\n        uint256 needed,\r\n        uint256 tokenId\r\n    );\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     */\r\n    error ERC1155InvalidSender(address sender);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\r\n     * @param receiver Address to which tokens are being transferred.\r\n     */\r\n    error ERC1155InvalidReceiver(address receiver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\r\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\r\n     * @param owner Address of the current owner of a token.\r\n     */\r\n    error ERC1155MissingApprovalForAll(address operator, address owner);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\r\n     * @param approver Address initiating an approval operation.\r\n     */\r\n    error ERC1155InvalidApprover(address approver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\r\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\r\n     */\r\n    error ERC1155InvalidOperator(address operator);\r\n\r\n    /**\r\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\r\n     * Used in batch transfers.\r\n     * @param idsLength Length of the array of token identifiers\r\n     * @param valuesLength Length of the array of token amounts\r\n     */\r\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * The default value of {decimals} is 18. To change this, you should override\r\n * this function so it returns a different value.\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n */\r\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the default value returned by this function, unless\r\n     * it's overridden.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `value`.\r\n     */\r\n    function transfer(address to, uint256 value) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 value)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `value`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `value`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) public virtual returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, value);\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        if (from == address(0)) {\r\n            revert ERC20InvalidSender(address(0));\r\n        }\r\n        if (to == address(0)) {\r\n            revert ERC20InvalidReceiver(address(0));\r\n        }\r\n        _update(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\r\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\r\n     * this function.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _update(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal virtual {\r\n        if (from == address(0)) {\r\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\r\n            _totalSupply += value;\r\n        } else {\r\n            uint256 fromBalance = _balances[from];\r\n            if (fromBalance < value) {\r\n                revert ERC20InsufficientBalance(from, fromBalance, value);\r\n            }\r\n            unchecked {\r\n                // Overflow not possible: value <= fromBalance <= totalSupply.\r\n                _balances[from] = fromBalance - value;\r\n            }\r\n        }\r\n\r\n        if (to == address(0)) {\r\n            unchecked {\r\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\r\n                _totalSupply -= value;\r\n            }\r\n        } else {\r\n            unchecked {\r\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\r\n                _balances[to] += value;\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\r\n     * Relies on the `_update` mechanism\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        if (account == address(0)) {\r\n            revert ERC20InvalidReceiver(address(0));\r\n        }\r\n        _update(address(0), account, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\r\n     * Relies on the `_update` mechanism.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * NOTE: This function is not virtual, {_update} should be overridden instead\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        if (account == address(0)) {\r\n            revert ERC20InvalidSender(address(0));\r\n        }\r\n        _update(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     *\r\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        _approve(owner, spender, value, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\r\n     *\r\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\r\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\r\n     * `Approval` event during `transferFrom` operations.\r\n     *\r\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\r\n     * true using the following override:\r\n     * ```\r\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\r\n     *     super._approve(owner, spender, value, true);\r\n     * }\r\n     * ```\r\n     *\r\n     * Requirements are the same as {_approve}.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        bool emitEvent\r\n    ) internal virtual {\r\n        if (owner == address(0)) {\r\n            revert ERC20InvalidApprover(address(0));\r\n        }\r\n        if (spender == address(0)) {\r\n            revert ERC20InvalidSpender(address(0));\r\n        }\r\n        _allowances[owner][spender] = value;\r\n        if (emitEvent) {\r\n            emit Approval(owner, spender, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\r\n     *\r\n     * Does not update the allowance value in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Does not emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 value\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            if (currentAllowance < value) {\r\n                revert ERC20InsufficientAllowance(\r\n                    spender,\r\n                    currentAllowance,\r\n                    value\r\n                );\r\n            }\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - value, false);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\r\n * tokens and those that they have an allowance for, in a way that can be\r\n * recognized off-chain (via event analysis).\r\n */\r\nabstract contract ERC20Burnable is Context, ERC20 {\r\n    /**\r\n     * @dev Destroys a `value` amount of tokens from the caller.\r\n     *\r\n     * See {ERC20-_burn}.\r\n     */\r\n    function burn(uint256 value) public virtual {\r\n        _burn(_msgSender(), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys a `value` amount of tokens from `account`, deducting from\r\n     * the caller's allowance.\r\n     *\r\n     * See {ERC20-_burn} and {ERC20-allowance}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have allowance for ``accounts``'s tokens of at least\r\n     * `value`.\r\n     */\r\n    function burnFrom(address account, uint256 value) public virtual {\r\n        _spendAllowance(account, _msgSender(), value);\r\n        _burn(account, value);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * The initial owner is set to the address provided by the deployer. This can\r\n * later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    /**\r\n     * @dev The caller account is not authorized to perform an operation.\r\n     */\r\n    error OwnableUnauthorizedAccount(address account);\r\n\r\n    /**\r\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\r\n     */\r\n    error OwnableInvalidOwner(address owner);\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\r\n     */\r\n    constructor(address initialOwner) {\r\n        if (initialOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(initialOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != _msgSender()) {\r\n            revert OwnableUnauthorizedAccount(_msgSender());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\ncontract AMMToken is ERC20, ERC20Burnable, Ownable(msg.sender) {\r\n    uint256 public constant MAX_SUPPLY = 10**9 * 10**18;\r\n    bool public finished;\r\n    string private _description;\r\n    string private _website;\r\n    string private _logoURL;\r\n\r\n    constructor(\r\n        string memory name,\r\n        string memory symbol,\r\n        string memory description_,\r\n        string memory website_,\r\n        string memory logoURL_\r\n    ) ERC20(name, symbol) {\r\n        _description = description_;\r\n        _website = website_;\r\n        _logoURL = logoURL_;\r\n    }\r\n\r\n    function approve(address spender, uint256 value)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        require(finished || spender == owner());\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, value);\r\n        return true;\r\n    }\r\n    \r\n    function finish() external onlyOwner {\r\n        finished = true;\r\n    }\r\n\r\n    function depositEth() external payable onlyOwner {\r\n    }\r\n\r\n    function withtrawEth(address to, uint256 amount) external onlyOwner {\r\n        payable(to).transfer(amount);\r\n    }\r\n\r\n\r\n    function mint(address to, uint256 amount) external onlyOwner {\r\n        require(totalSupply() + amount <= MAX_SUPPLY, \"Exceeds max supply\");\r\n        _mint(to, amount);\r\n    }\r\n\r\n    function description() public view returns (string memory) {\r\n        return _description;\r\n    }\r\n\r\n    function website() public view returns (string memory) {\r\n        return _website;\r\n    }\r\n\r\n    function logoURL() public view returns (string memory) {\r\n        return _logoURL;\r\n    }\r\n}",
        "fileIndex": 0,
        "fileName": "AMMToken.sol",
        "id": 20,
        "path": "AMMToken.sol"
      }
    ],
    "0xb7d84205eaaf83ce7b3940c6beaad6d22790255e34a9a2b486aa8cdfff118fe6": [
      {
        "code": "/**\r\n *Submitted for verification at Bscscan.com on 2020-09-03\r\n*/\r\n\r\npragma solidity ^0.4.18;\r\n\r\ncontract WBNB {\r\n    string public name     = \"Wrapped BNB\";\r\n    string public symbol   = \"WBNB\";\r\n    uint8  public decimals = 18;\r\n\r\n    event  Approval(address indexed src, address indexed guy, uint wad);\r\n    event  Transfer(address indexed src, address indexed dst, uint wad);\r\n    event  Deposit(address indexed dst, uint wad);\r\n    event  Withdrawal(address indexed src, uint wad);\r\n\r\n    mapping (address => uint)                       public  balanceOf;\r\n    mapping (address => mapping (address => uint))  public  allowance;\r\n\r\n    function() public payable {\r\n        deposit();\r\n    }\r\n    function deposit() public payable {\r\n        balanceOf[msg.sender] += msg.value;\r\n        Deposit(msg.sender, msg.value);\r\n    }\r\n    function withdraw(uint wad) public {\r\n        require(balanceOf[msg.sender] >= wad);\r\n        balanceOf[msg.sender] -= wad;\r\n        msg.sender.transfer(wad);\r\n        Withdrawal(msg.sender, wad);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return this.balance;\r\n    }\r\n\r\n    function approve(address guy, uint wad) public returns (bool) {\r\n        allowance[msg.sender][guy] = wad;\r\n        Approval(msg.sender, guy, wad);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint wad) public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n    public\r\n    returns (bool)\r\n    {\r\n        require(balanceOf[src] >= wad);\r\n\r\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\r\n            require(allowance[src][msg.sender] >= wad);\r\n            allowance[src][msg.sender] -= wad;\r\n        }\r\n\r\n        balanceOf[src] -= wad;\r\n        balanceOf[dst] += wad;\r\n\r\n        Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n/*\r\n                    GNU GENERAL PUBLIC LICENSE\r\n                       Version 3, 29 June 2007\r\n\r\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\r\n Everyone is permitted to copy and distribute verbatim copies\r\n of this license document, but changing it is not allowed.\r\n\r\n                            Preamble\r\n\r\n  The GNU General Public License is a free, copyleft license for\r\nsoftware and other kinds of works.\r\n\r\n  The licenses for most software and other practical works are designed\r\nto take away your freedom to share and change the works.  By contrast,\r\nthe GNU General Public License is intended to guarantee your freedom to\r\nshare and change all versions of a program--to make sure it remains free\r\nsoftware for all its users.  We, the Free Software Foundation, use the\r\nGNU General Public License for most of our software; it applies also to\r\nany other work released this way by its authors.  You can apply it to\r\nyour programs, too.\r\n\r\n  When we speak of free software, we are referring to freedom, not\r\nprice.  Our General Public Licenses are designed to make sure that you\r\nhave the freedom to distribute copies of free software (and charge for\r\nthem if you wish), that you receive source code or can get it if you\r\nwant it, that you can change the software or use pieces of it in new\r\nfree programs, and that you know you can do these things.\r\n\r\n  To protect your rights, we need to prevent others from denying you\r\nthese rights or asking you to surrender the rights.  Therefore, you have\r\ncertain responsibilities if you distribute copies of the software, or if\r\nyou modify it: responsibilities to respect the freedom of others.\r\n\r\n  For example, if you distribute copies of such a program, whether\r\ngratis or for a fee, you must pass on to the recipients the same\r\nfreedoms that you received.  You must make sure that they, too, receive\r\nor can get the source code.  And you must show them these terms so they\r\nknow their rights.\r\n\r\n  Developers that use the GNU GPL protect your rights with two steps:\r\n(1) assert copyright on the software, and (2) offer you this License\r\ngiving you legal permission to copy, distribute and/or modify it.\r\n\r\n  For the developers' and authors' protection, the GPL clearly explains\r\nthat there is no warranty for this free software.  For both users' and\r\nauthors' sake, the GPL requires that modified versions be marked as\r\nchanged, so that their problems will not be attributed erroneously to\r\nauthors of previous versions.\r\n\r\n  Some devices are designed to deny users access to install or run\r\nmodified versions of the software inside them, although the manufacturer\r\ncan do so.  This is fundamentally incompatible with the aim of\r\nprotecting users' freedom to change the software.  The systematic\r\npattern of such abuse occurs in the area of products for individuals to\r\nuse, which is precisely where it is most unacceptable.  Therefore, we\r\nhave designed this version of the GPL to prohibit the practice for those\r\nproducts.  If such problems arise substantially in other domains, we\r\nstand ready to extend this provision to those domains in future versions\r\nof the GPL, as needed to protect the freedom of users.\r\n\r\n  Finally, every program is threatened constantly by software patents.\r\nStates should not allow patents to restrict development and use of\r\nsoftware on general-purpose computers, but in those that do, we wish to\r\navoid the special danger that patents applied to a free program could\r\nmake it effectively proprietary.  To prevent this, the GPL assures that\r\npatents cannot be used to render the program non-free.\r\n\r\n  The precise terms and conditions for copying, distribution and\r\nmodification follow.\r\n\r\n                       TERMS AND CONDITIONS\r\n\r\n  0. Definitions.\r\n\r\n  \"This License\" refers to version 3 of the GNU General Public License.\r\n\r\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\r\nworks, such as semiconductor masks.\r\n\r\n  \"The Program\" refers to any copyrightable work licensed under this\r\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\r\n\"recipients\" may be individuals or organizations.\r\n\r\n  To \"modify\" a work means to copy from or adapt all or part of the work\r\nin a fashion requiring copyright permission, other than the making of an\r\nexact copy.  The resulting work is called a \"modified version\" of the\r\nearlier work or a work \"based on\" the earlier work.\r\n\r\n  A \"covered work\" means either the unmodified Program or a work based\r\non the Program.\r\n\r\n  To \"propagate\" a work means to do anything with it that, without\r\npermission, would make you directly or secondarily liable for\r\ninfringement under applicable copyright law, except executing it on a\r\ncomputer or modifying a private copy.  Propagation includes copying,\r\ndistribution (with or without modification), making available to the\r\npublic, and in some countries other activities as well.\r\n\r\n  To \"convey\" a work means any kind of propagation that enables other\r\nparties to make or receive copies.  Mere interaction with a user through\r\na computer network, with no transfer of a copy, is not conveying.\r\n\r\n  An interactive user interface displays \"Appropriate Legal Notices\"\r\nto the extent that it includes a convenient and prominently visible\r\nfeature that (1) displays an appropriate copyright notice, and (2)\r\ntells the user that there is no warranty for the work (except to the\r\nextent that warranties are provided), that licensees may convey the\r\nwork under this License, and how to view a copy of this License.  If\r\nthe interface presents a list of user commands or options, such as a\r\nmenu, a prominent item in the list meets this criterion.\r\n\r\n  1. Source Code.\r\n\r\n  The \"source code\" for a work means the preferred form of the work\r\nfor making modifications to it.  \"Object code\" means any non-source\r\nform of a work.\r\n\r\n  A \"Standard Interface\" means an interface that either is an official\r\nstandard defined by a recognized standards body, or, in the case of\r\ninterfaces specified for a particular programming language, one that\r\nis widely used among developers working in that language.\r\n\r\n  The \"System Libraries\" of an executable work include anything, other\r\nthan the work as a whole, that (a) is included in the normal form of\r\npackaging a Major Component, but which is not part of that Major\r\nComponent, and (b) serves only to enable use of the work with that\r\nMajor Component, or to implement a Standard Interface for which an\r\nimplementation is available to the public in source code form.  A\r\n\"Major Component\", in this context, means a major essential component\r\n(kernel, window system, and so on) of the specific operating system\r\n(if any) on which the executable work runs, or a compiler used to\r\nproduce the work, or an object code interpreter used to run it.\r\n\r\n  The \"Corresponding Source\" for a work in object code form means all\r\nthe source code needed to generate, install, and (for an executable\r\nwork) run the object code and to modify the work, including scripts to\r\ncontrol those activities.  However, it does not include the work's\r\nSystem Libraries, or general-purpose tools or generally available free\r\nprograms which are used unmodified in performing those activities but\r\nwhich are not part of the work.  For example, Corresponding Source\r\nincludes interface definition files associated with source files for\r\nthe work, and the source code for shared libraries and dynamically\r\nlinked subprograms that the work is specifically designed to require,\r\nsuch as by intimate data communication or control flow between those\r\nsubprograms and other parts of the work.\r\n\r\n  The Corresponding Source need not include anything that users\r\ncan regenerate automatically from other parts of the Corresponding\r\nSource.\r\n\r\n  The Corresponding Source for a work in source code form is that\r\nsame work.\r\n\r\n  2. Basic Permissions.\r\n\r\n  All rights granted under this License are granted for the term of\r\ncopyright on the Program, and are irrevocable provided the stated\r\nconditions are met.  This License explicitly affirms your unlimited\r\npermission to run the unmodified Program.  The output from running a\r\ncovered work is covered by this License only if the output, given its\r\ncontent, constitutes a covered work.  This License acknowledges your\r\nrights of fair use or other equivalent, as provided by copyright law.\r\n\r\n  You may make, run and propagate covered works that you do not\r\nconvey, without conditions so long as your license otherwise remains\r\nin force.  You may convey covered works to others for the sole purpose\r\nof having them make modifications exclusively for you, or provide you\r\nwith facilities for running those works, provided that you comply with\r\nthe terms of this License in conveying all material for which you do\r\nnot control copyright.  Those thus making or running the covered works\r\nfor you must do so exclusively on your behalf, under your direction\r\nand control, on terms that prohibit them from making any copies of\r\nyour copyrighted material outside their relationship with you.\r\n\r\n  Conveying under any other circumstances is permitted solely under\r\nthe conditions stated below.  Sublicensing is not allowed; section 10\r\nmakes it unnecessary.\r\n\r\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\r\n\r\n  No covered work shall be deemed part of an effective technological\r\nmeasure under any applicable law fulfilling obligations under article\r\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\r\nsimilar laws prohibiting or restricting circumvention of such\r\nmeasures.\r\n\r\n  When you convey a covered work, you waive any legal power to forbid\r\ncircumvention of technological measures to the extent such circumvention\r\nis effected by exercising rights under this License with respect to\r\nthe covered work, and you disclaim any intention to limit operation or\r\nmodification of the work as a means of enforcing, against the work's\r\nusers, your or third parties' legal rights to forbid circumvention of\r\ntechnological measures.\r\n\r\n  4. Conveying Verbatim Copies.\r\n\r\n  You may convey verbatim copies of the Program's source code as you\r\nreceive it, in any medium, provided that you conspicuously and\r\nappropriately publish on each copy an appropriate copyright notice;\r\nkeep intact all notices stating that this License and any\r\nnon-permissive terms added in accord with section 7 apply to the code;\r\nkeep intact all notices of the absence of any warranty; and give all\r\nrecipients a copy of this License along with the Program.\r\n\r\n  You may charge any price or no price for each copy that you convey,\r\nand you may offer support or warranty protection for a fee.\r\n\r\n  5. Conveying Modified Source Versions.\r\n\r\n  You may convey a work based on the Program, or the modifications to\r\nproduce it from the Program, in the form of source code under the\r\nterms of section 4, provided that you also meet all of these conditions:\r\n\r\n    a) The work must carry prominent notices stating that you modified\r\n    it, and giving a relevant date.\r\n\r\n    b) The work must carry prominent notices stating that it is\r\n    released under this License and any conditions added under section\r\n    7.  This requirement modifies the requirement in section 4 to\r\n    \"keep intact all notices\".\r\n\r\n    c) You must license the entire work, as a whole, under this\r\n    License to anyone who comes into possession of a copy.  This\r\n    License will therefore apply, along with any applicable section 7\r\n    additional terms, to the whole of the work, and all its parts,\r\n    regardless of how they are packaged.  This License gives no\r\n    permission to license the work in any other way, but it does not\r\n    invalidate such permission if you have separately received it.\r\n\r\n    d) If the work has interactive user interfaces, each must display\r\n    Appropriate Legal Notices; however, if the Program has interactive\r\n    interfaces that do not display Appropriate Legal Notices, your\r\n    work need not make them do so.\r\n\r\n  A compilation of a covered work with other separate and independent\r\nworks, which are not by their nature extensions of the covered work,\r\nand which are not combined with it such as to form a larger program,\r\nin or on a volume of a storage or distribution medium, is called an\r\n\"aggregate\" if the compilation and its resulting copyright are not\r\nused to limit the access or legal rights of the compilation's users\r\nbeyond what the individual works permit.  Inclusion of a covered work\r\nin an aggregate does not cause this License to apply to the other\r\nparts of the aggregate.\r\n\r\n  6. Conveying Non-Source Forms.\r\n\r\n  You may convey a covered work in object code form under the terms\r\nof sections 4 and 5, provided that you also convey the\r\nmachine-readable Corresponding Source under the terms of this License,\r\nin one of these ways:\r\n\r\n    a) Convey the object code in, or embodied in, a physical product\r\n    (including a physical distribution medium), accompanied by the\r\n    Corresponding Source fixed on a durable physical medium\r\n    customarily used for software interchange.\r\n\r\n    b) Convey the object code in, or embodied in, a physical product\r\n    (including a physical distribution medium), accompanied by a\r\n    written offer, valid for at least three years and valid for as\r\n    long as you offer spare parts or customer support for that product\r\n    model, to give anyone who possesses the object code either (1) a\r\n    copy of the Corresponding Source for all the software in the\r\n    product that is covered by this License, on a durable physical\r\n    medium customarily used for software interchange, for a price no\r\n    more than your reasonable cost of physically performing this\r\n    conveying of source, or (2) access to copy the\r\n    Corresponding Source from a network server at no charge.\r\n\r\n    c) Convey individual copies of the object code with a copy of the\r\n    written offer to provide the Corresponding Source.  This\r\n    alternative is allowed only occasionally and noncommercially, and\r\n    only if you received the object code with such an offer, in accord\r\n    with subsection 6b.\r\n\r\n    d) Convey the object code by offering access from a designated\r\n    place (gratis or for a charge), and offer equivalent access to the\r\n    Corresponding Source in the same way through the same place at no\r\n    further charge.  You need not require recipients to copy the\r\n    Corresponding Source along with the object code.  If the place to\r\n    copy the object code is a network server, the Corresponding Source\r\n    may be on a different server (operated by you or a third party)\r\n    that supports equivalent copying facilities, provided you maintain\r\n    clear directions next to the object code saying where to find the\r\n    Corresponding Source.  Regardless of what server hosts the\r\n    Corresponding Source, you remain obligated to ensure that it is\r\n    available for as long as needed to satisfy these requirements.\r\n\r\n    e) Convey the object code using peer-to-peer transmission, provided\r\n    you inform other peers where the object code and Corresponding\r\n    Source of the work are being offered to the general public at no\r\n    charge under subsection 6d.\r\n\r\n  A separable portion of the object code, whose source code is excluded\r\nfrom the Corresponding Source as a System Library, need not be\r\nincluded in conveying the object code work.\r\n\r\n  A \"User Product\" is either (1) a \"consumer product\", which means any\r\ntangible personal property which is normally used for personal, family,\r\nor household purposes, or (2) anything designed or sold for incorporation\r\ninto a dwelling.  In determining whether a product is a consumer product,\r\ndoubtful cases shall be resolved in favor of coverage.  For a particular\r\nproduct received by a particular user, \"normally used\" refers to a\r\ntypical or common use of that class of product, regardless of the status\r\nof the particular user or of the way in which the particular user\r\nactually uses, or expects or is expected to use, the product.  A product\r\nis a consumer product regardless of whether the product has substantial\r\ncommercial, industrial or non-consumer uses, unless such uses represent\r\nthe only significant mode of use of the product.\r\n\r\n  \"Installation Information\" for a User Product means any methods,\r\nprocedures, authorization keys, or other information required to install\r\nand execute modified versions of a covered work in that User Product from\r\na modified version of its Corresponding Source.  The information must\r\nsuffice to ensure that the continued functioning of the modified object\r\ncode is in no case prevented or interfered with solely because\r\nmodification has been made.\r\n\r\n  If you convey an object code work under this section in, or with, or\r\nspecifically for use in, a User Product, and the conveying occurs as\r\npart of a transaction in which the right of possession and use of the\r\nUser Product is transferred to the recipient in perpetuity or for a\r\nfixed term (regardless of how the transaction is characterized), the\r\nCorresponding Source conveyed under this section must be accompanied\r\nby the Installation Information.  But this requirement does not apply\r\nif neither you nor any third party retains the ability to install\r\nmodified object code on the User Product (for example, the work has\r\nbeen installed in ROM).\r\n\r\n  The requirement to provide Installation Information does not include a\r\nrequirement to continue to provide support service, warranty, or updates\r\nfor a work that has been modified or installed by the recipient, or for\r\nthe User Product in which it has been modified or installed.  Access to a\r\nnetwork may be denied when the modification itself materially and\r\nadversely affects the operation of the network or violates the rules and\r\nprotocols for communication across the network.\r\n\r\n  Corresponding Source conveyed, and Installation Information provided,\r\nin accord with this section must be in a format that is publicly\r\ndocumented (and with an implementation available to the public in\r\nsource code form), and must require no special password or key for\r\nunpacking, reading or copying.\r\n\r\n  7. Additional Terms.\r\n\r\n  \"Additional permissions\" are terms that supplement the terms of this\r\nLicense by making exceptions from one or more of its conditions.\r\nAdditional permissions that are applicable to the entire Program shall\r\nbe treated as though they were included in this License, to the extent\r\nthat they are valid under applicable law.  If additional permissions\r\napply only to part of the Program, that part may be used separately\r\nunder those permissions, but the entire Program remains governed by\r\nthis License without regard to the additional permissions.\r\n\r\n  When you convey a copy of a covered work, you may at your option\r\nremove any additional permissions from that copy, or from any part of\r\nit.  (Additional permissions may be written to require their own\r\nremoval in certain cases when you modify the work.)  You may place\r\nadditional permissions on material, added by you to a covered work,\r\nfor which you have or can give appropriate copyright permission.\r\n\r\n  Notwithstanding any other provision of this License, for material you\r\nadd to a covered work, you may (if authorized by the copyright holders of\r\nthat material) supplement the terms of this License with terms:\r\n\r\n    a) Disclaiming warranty or limiting liability differently from the\r\n    terms of sections 15 and 16 of this License; or\r\n\r\n    b) Requiring preservation of specified reasonable legal notices or\r\n    author attributions in that material or in the Appropriate Legal\r\n    Notices displayed by works containing it; or\r\n\r\n    c) Prohibiting misrepresentation of the origin of that material, or\r\n    requiring that modified versions of such material be marked in\r\n    reasonable ways as different from the original version; or\r\n\r\n    d) Limiting the use for publicity purposes of names of licensors or\r\n    authors of the material; or\r\n\r\n    e) Declining to grant rights under trademark law for use of some\r\n    trade names, trademarks, or service marks; or\r\n\r\n    f) Requiring indemnification of licensors and authors of that\r\n    material by anyone who conveys the material (or modified versions of\r\n    it) with contractual assumptions of liability to the recipient, for\r\n    any liability that these contractual assumptions directly impose on\r\n    those licensors and authors.\r\n\r\n  All other non-permissive additional terms are considered \"further\r\nrestrictions\" within the meaning of section 10.  If the Program as you\r\nreceived it, or any part of it, contains a notice stating that it is\r\ngoverned by this License along with a term that is a further\r\nrestriction, you may remove that term.  If a license document contains\r\na further restriction but permits relicensing or conveying under this\r\nLicense, you may add to a covered work material governed by the terms\r\nof that license document, provided that the further restriction does\r\nnot survive such relicensing or conveying.\r\n\r\n  If you add terms to a covered work in accord with this section, you\r\nmust place, in the relevant source files, a statement of the\r\nadditional terms that apply to those files, or a notice indicating\r\nwhere to find the applicable terms.\r\n\r\n  Additional terms, permissive or non-permissive, may be stated in the\r\nform of a separately written license, or stated as exceptions;\r\nthe above requirements apply either way.\r\n\r\n  8. Termination.\r\n\r\n  You may not propagate or modify a covered work except as expressly\r\nprovided under this License.  Any attempt otherwise to propagate or\r\nmodify it is void, and will automatically terminate your rights under\r\nthis License (including any patent licenses granted under the third\r\nparagraph of section 11).\r\n\r\n  However, if you cease all violation of this License, then your\r\nlicense from a particular copyright holder is reinstated (a)\r\nprovisionally, unless and until the copyright holder explicitly and\r\nfinally terminates your license, and (b) permanently, if the copyright\r\nholder fails to notify you of the violation by some reasonable means\r\nprior to 60 days after the cessation.\r\n\r\n  Moreover, your license from a particular copyright holder is\r\nreinstated permanently if the copyright holder notifies you of the\r\nviolation by some reasonable means, this is the first time you have\r\nreceived notice of violation of this License (for any work) from that\r\ncopyright holder, and you cure the violation prior to 30 days after\r\nyour receipt of the notice.\r\n\r\n  Termination of your rights under this section does not terminate the\r\nlicenses of parties who have received copies or rights from you under\r\nthis License.  If your rights have been terminated and not permanently\r\nreinstated, you do not qualify to receive new licenses for the same\r\nmaterial under section 10.\r\n\r\n  9. Acceptance Not Required for Having Copies.\r\n\r\n  You are not required to accept this License in order to receive or\r\nrun a copy of the Program.  Ancillary propagation of a covered work\r\noccurring solely as a consequence of using peer-to-peer transmission\r\nto receive a copy likewise does not require acceptance.  However,\r\nnothing other than this License grants you permission to propagate or\r\nmodify any covered work.  These actions infringe copyright if you do\r\nnot accept this License.  Therefore, by modifying or propagating a\r\ncovered work, you indicate your acceptance of this License to do so.\r\n\r\n  10. Automatic Licensing of Downstream Recipients.\r\n\r\n  Each time you convey a covered work, the recipient automatically\r\nreceives a license from the original licensors, to run, modify and\r\npropagate that work, subject to this License.  You are not responsible\r\nfor enforcing compliance by third parties with this License.\r\n\r\n  An \"entity transaction\" is a transaction transferring control of an\r\norganization, or substantially all assets of one, or subdividing an\r\norganization, or merging organizations.  If propagation of a covered\r\nwork results from an entity transaction, each party to that\r\ntransaction who receives a copy of the work also receives whatever\r\nlicenses to the work the party's predecessor in interest had or could\r\ngive under the previous paragraph, plus a right to possession of the\r\nCorresponding Source of the work from the predecessor in interest, if\r\nthe predecessor has it or can get it with reasonable efforts.\r\n\r\n  You may not impose any further restrictions on the exercise of the\r\nrights granted or affirmed under this License.  For example, you may\r\nnot impose a license fee, royalty, or other charge for exercise of\r\nrights granted under this License, and you may not initiate litigation\r\n(including a cross-claim or counterclaim in a lawsuit) alleging that\r\nany patent claim is infringed by making, using, selling, offering for\r\nsale, or importing the Program or any portion of it.\r\n\r\n  11. Patents.\r\n\r\n  A \"contributor\" is a copyright holder who authorizes use under this\r\nLicense of the Program or a work on which the Program is based.  The\r\nwork thus licensed is called the contributor's \"contributor version\".\r\n\r\n  A contributor's \"essential patent claims\" are all patent claims\r\nowned or controlled by the contributor, whether already acquired or\r\nhereafter acquired, that would be infringed by some manner, permitted\r\nby this License, of making, using, or selling its contributor version,\r\nbut do not include claims that would be infringed only as a\r\nconsequence of further modification of the contributor version.  For\r\npurposes of this definition, \"control\" includes the right to grant\r\npatent sublicenses in a manner consistent with the requirements of\r\nthis License.\r\n\r\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\r\npatent license under the contributor's essential patent claims, to\r\nmake, use, sell, offer for sale, import and otherwise run, modify and\r\npropagate the contents of its contributor version.\r\n\r\n  In the following three paragraphs, a \"patent license\" is any express\r\nagreement or commitment, however denominated, not to enforce a patent\r\n(such as an express permission to practice a patent or covenant not to\r\nsue for patent infringement).  To \"grant\" such a patent license to a\r\nparty means to make such an agreement or commitment not to enforce a\r\npatent against the party.\r\n\r\n  If you convey a covered work, knowingly relying on a patent license,\r\nand the Corresponding Source of the work is not available for anyone\r\nto copy, free of charge and under the terms of this License, through a\r\npublicly available network server or other readily accessible means,\r\nthen you must either (1) cause the Corresponding Source to be so\r\navailable, or (2) arrange to deprive yourself of the benefit of the\r\npatent license for this particular work, or (3) arrange, in a manner\r\nconsistent with the requirements of this License, to extend the patent\r\nlicense to downstream recipients.  \"Knowingly relying\" means you have\r\nactual knowledge that, but for the patent license, your conveying the\r\ncovered work in a country, or your recipient's use of the covered work\r\nin a country, would infringe one or more identifiable patents in that\r\ncountry that you have reason to believe are valid.\r\n\r\n  If, pursuant to or in connection with a single transaction or\r\narrangement, you convey, or propagate by procuring conveyance of, a\r\ncovered work, and grant a patent license to some of the parties\r\nreceiving the covered work authorizing them to use, propagate, modify\r\nor convey a specific copy of the covered work, then the patent license\r\nyou grant is automatically extended to all recipients of the covered\r\nwork and works based on it.\r\n\r\n  A patent license is \"discriminatory\" if it does not include within\r\nthe scope of its coverage, prohibits the exercise of, or is\r\nconditioned on the non-exercise of one or more of the rights that are\r\nspecifically granted under this License.  You may not convey a covered\r\nwork if you are a party to an arrangement with a third party that is\r\nin the business of distributing software, under which you make payment\r\nto the third party based on the extent of your activity of conveying\r\nthe work, and under which the third party grants, to any of the\r\nparties who would receive the covered work from you, a discriminatory\r\npatent license (a) in connection with copies of the covered work\r\nconveyed by you (or copies made from those copies), or (b) primarily\r\nfor and in connection with specific products or compilations that\r\ncontain the covered work, unless you entered into that arrangement,\r\nor that patent license was granted, prior to 28 March 2007.\r\n\r\n  Nothing in this License shall be construed as excluding or limiting\r\nany implied license or other defenses to infringement that may\r\notherwise be available to you under applicable patent law.\r\n\r\n  12. No Surrender of Others' Freedom.\r\n\r\n  If conditions are imposed on you (whether by court order, agreement or\r\notherwise) that contradict the conditions of this License, they do not\r\nexcuse you from the conditions of this License.  If you cannot convey a\r\ncovered work so as to satisfy simultaneously your obligations under this\r\nLicense and any other pertinent obligations, then as a consequence you may\r\nnot convey it at all.  For example, if you agree to terms that obligate you\r\nto collect a royalty for further conveying from those to whom you convey\r\nthe Program, the only way you could satisfy both those terms and this\r\nLicense would be to refrain entirely from conveying the Program.\r\n\r\n  13. Use with the GNU Affero General Public License.\r\n\r\n  Notwithstanding any other provision of this License, you have\r\npermission to link or combine any covered work with a work licensed\r\nunder version 3 of the GNU Affero General Public License into a single\r\ncombined work, and to convey the resulting work.  The terms of this\r\nLicense will continue to apply to the part which is the covered work,\r\nbut the special requirements of the GNU Affero General Public License,\r\nsection 13, concerning interaction through a network will apply to the\r\ncombination as such.\r\n\r\n  14. Revised Versions of this License.\r\n\r\n  The Free Software Foundation may publish revised and/or new versions of\r\nthe GNU General Public License from time to time.  Such new versions will\r\nbe similar in spirit to the present version, but may differ in detail to\r\naddress new problems or concerns.\r\n\r\n  Each version is given a distinguishing version number.  If the\r\nProgram specifies that a certain numbered version of the GNU General\r\nPublic License \"or any later version\" applies to it, you have the\r\noption of following the terms and conditions either of that numbered\r\nversion or of any later version published by the Free Software\r\nFoundation.  If the Program does not specify a version number of the\r\nGNU General Public License, you may choose any version ever published\r\nby the Free Software Foundation.\r\n\r\n  If the Program specifies that a proxy can decide which future\r\nversions of the GNU General Public License can be used, that proxy's\r\npublic statement of acceptance of a version permanently authorizes you\r\nto choose that version for the Program.\r\n\r\n  Later license versions may give you additional or different\r\npermissions.  However, no additional obligations are imposed on any\r\nauthor or copyright holder as a result of your choosing to follow a\r\nlater version.\r\n\r\n  15. Disclaimer of Warranty.\r\n\r\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\r\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\r\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\r\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\r\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\r\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\r\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\r\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\r\n\r\n  16. Limitation of Liability.\r\n\r\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\r\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\r\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\r\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\r\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\r\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\r\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\r\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\r\nSUCH DAMAGES.\r\n\r\n  17. Interpretation of Sections 15 and 16.\r\n\r\n  If the disclaimer of warranty and limitation of liability provided\r\nabove cannot be given local legal effect according to their terms,\r\nreviewing courts shall apply local law that most closely approximates\r\nan absolute waiver of all civil liability in connection with the\r\nProgram, unless a warranty or assumption of liability accompanies a\r\ncopy of the Program in return for a fee.\r\n\r\n                     END OF TERMS AND CONDITIONS\r\n\r\n            How to Apply These Terms to Your New Programs\r\n\r\n  If you develop a new program, and you want it to be of the greatest\r\npossible use to the public, the best way to achieve this is to make it\r\nfree software which everyone can redistribute and change under these terms.\r\n\r\n  To do so, attach the following notices to the program.  It is safest\r\nto attach them to the start of each source file to most effectively\r\nstate the exclusion of warranty; and each file should have at least\r\nthe \"copyright\" line and a pointer to where the full notice is found.\r\n\r\n    <one line to give the program's name and a brief idea of what it does.>\r\n    Copyright (C) <year>  <name of author>\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\nAlso add information on how to contact you by electronic and paper mail.\r\n\r\n  If the program does terminal interaction, make it output a short\r\nnotice like this when it starts in an interactive mode:\r\n\r\n    <program>  Copyright (C) <year>  <name of author>\r\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\r\n    This is free software, and you are welcome to redistribute it\r\n    under certain conditions; type `show c' for details.\r\n\r\nThe hypothetical commands `show w' and `show c' should show the appropriate\r\nparts of the General Public License.  Of course, your program's commands\r\nmight be different; for a GUI interface, you would use an \"about box\".\r\n\r\n  You should also get your employer (if you work as a programmer) or school,\r\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\r\nFor more information on this, and how to apply and follow the GNU GPL, see\r\n<http://www.gnu.org/licenses/>.\r\n\r\n  The GNU General Public License does not permit incorporating your program\r\ninto proprietary programs.  If your program is a subroutine library, you\r\nmay consider it more useful to permit linking proprietary applications with\r\nthe library.  If this is what you want to do, use the GNU Lesser General\r\nPublic License instead of this License.  But first, please read\r\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\r\n\r\n*/",
        "fileIndex": 0,
        "fileName": "WBNB.sol",
        "id": 18,
        "path": "WBNB.sol"
      }
    ],
    "0xb89c1b3bdf2cf8827818646bce9a8f6e372885f8c55e5c07acbd307cb133b000": [
      {
        "code": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ninterface IProxy {\r\n    function masterCopy() external view returns (address);\r\n}\r\n\r\n/// @title GnosisSafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\r\n/// @author Stefan George - <stefan@gnosis.io>\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ncontract GnosisSafeProxy {\r\n    // singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\r\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\r\n    address internal singleton;\r\n\r\n    /// @dev Constructor function sets address of singleton contract.\r\n    /// @param _singleton Singleton address.\r\n    constructor(address _singleton) {\r\n        require(_singleton != address(0), \"Invalid singleton address provided\");\r\n        singleton = _singleton;\r\n    }\r\n\r\n    /// @dev Fallback function forwards all transactions and returns all received return data.\r\n    fallback() external payable {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\r\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\r\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\r\n                mstore(0, _singleton)\r\n                return(0, 0x20)\r\n            }\r\n            calldatacopy(0, 0, calldatasize())\r\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            if eq(success, 0) {\r\n                revert(0, returndatasize())\r\n            }\r\n            return(0, returndatasize())\r\n        }\r\n    }\r\n}\r\n\r\n/// @title Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\ncontract GnosisSafeProxyFactory {\r\n    event ProxyCreation(GnosisSafeProxy proxy, address singleton);\r\n\r\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n    /// @param singleton Address of singleton contract.\r\n    /// @param data Payload for message call sent to new proxy contract.\r\n    function createProxy(address singleton, bytes memory data) public returns (GnosisSafeProxy proxy) {\r\n        proxy = new GnosisSafeProxy(singleton);\r\n        if (data.length > 0)\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                if eq(call(gas(), proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) {\r\n                    revert(0, 0)\r\n                }\r\n            }\r\n        emit ProxyCreation(proxy, singleton);\r\n    }\r\n\r\n    /// @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\r\n    function proxyRuntimeCode() public pure returns (bytes memory) {\r\n        return type(GnosisSafeProxy).runtimeCode;\r\n    }\r\n\r\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\r\n    function proxyCreationCode() public pure returns (bytes memory) {\r\n        return type(GnosisSafeProxy).creationCode;\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\r\n    ///      This method is only meant as an utility to be called from other methods\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function deployProxyWithNonce(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce\r\n    ) internal returns (GnosisSafeProxy proxy) {\r\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\r\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\r\n        bytes memory deploymentData = abi.encodePacked(type(GnosisSafeProxy).creationCode, uint256(uint160(_singleton)));\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\r\n        }\r\n        require(address(proxy) != address(0), \"Create2 call failed\");\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function createProxyWithNonce(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce\r\n    ) public returns (GnosisSafeProxy proxy) {\r\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\r\n        if (initializer.length > 0)\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) {\r\n                    revert(0, 0)\r\n                }\r\n            }\r\n        emit ProxyCreation(proxy, _singleton);\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    /// @param callback Callback that will be invoced after the new proxy contract has been successfully deployed and initialized.\r\n    function createProxyWithCallback(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce,\r\n        IProxyCreationCallback callback\r\n    ) public returns (GnosisSafeProxy proxy) {\r\n        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));\r\n        proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback);\r\n        if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce);\r\n    }\r\n\r\n    /// @dev Allows to get the address for a new proxy contact created via `createProxyWithNonce`\r\n    ///      This method is only meant for address calculation purpose when you use an initializer that would revert,\r\n    ///      therefore the response is returned with a revert. When calling this method set `from` to the address of the proxy factory.\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function calculateCreateProxyWithNonceAddress(\r\n        address _singleton,\r\n        bytes calldata initializer,\r\n        uint256 saltNonce\r\n    ) external returns (GnosisSafeProxy proxy) {\r\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\r\n        revert(string(abi.encodePacked(proxy)));\r\n    }\r\n}\r\n\r\ninterface IProxyCreationCallback {\r\n    function proxyCreated(\r\n        GnosisSafeProxy proxy,\r\n        address _singleton,\r\n        bytes calldata initializer,\r\n        uint256 saltNonce\r\n    ) external;\r\n}",
        "fileIndex": 0,
        "fileName": "GnosisSafeProxy.sol",
        "id": 19,
        "path": "GnosisSafeProxy.sol"
      }
    ],
    "0xc2be4f894c1c91337f977f51694ecd95489fb2a9b55b45a6a33990e32029a3fe": [
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n",
        "fileIndex": 0,
        "fileName": "Ownable.sol",
        "id": 41,
        "path": "@openzeppelin/contracts/access/Ownable.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n",
        "fileIndex": 1,
        "fileName": "ReentrancyGuard.sol",
        "id": 42,
        "path": "@openzeppelin/contracts/security/ReentrancyGuard.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n",
        "fileIndex": 2,
        "fileName": "IERC20Permit.sol",
        "id": 43,
        "path": "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n",
        "fileIndex": 3,
        "fileName": "IERC20.sol",
        "id": 44,
        "path": "@openzeppelin/contracts/token/ERC20/IERC20.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n",
        "fileIndex": 4,
        "fileName": "SafeERC20.sol",
        "id": 45,
        "path": "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n",
        "fileIndex": 5,
        "fileName": "Address.sol",
        "id": 46,
        "path": "@openzeppelin/contracts/utils/Address.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n",
        "fileIndex": 6,
        "fileName": "Context.sol",
        "id": 47,
        "path": "@openzeppelin/contracts/utils/Context.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n",
        "fileIndex": 7,
        "fileName": "SafeMath.sol",
        "id": 48,
        "path": "@openzeppelin/contracts/utils/math/SafeMath.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\naddress constant _GPC = 0xD3c304697f63B279cd314F92c19cDBE5E5b1631A;\naddress constant _ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\naddress constant DEAD_WALLET = 0x000000000000000000000000000000000000dEaD;\naddress constant _WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\naddress constant _USDC = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;\naddress constant _USDT = 0x55d398326f99059fF775485246999027B3197955;\n",
        "fileIndex": 8,
        "fileName": "Const.sol",
        "id": 49,
        "path": "contracts/Const.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\ninterface IMSC {\n    function  mscPrice() external view returns(uint256);\n}",
        "fileIndex": 9,
        "fileName": "IMSC.sol",
        "id": 50,
        "path": "contracts/IMSC.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\ninterface IPancakePair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}",
        "fileIndex": 10,
        "fileName": "IPancakePair.sol",
        "id": 51,
        "path": "contracts/IPancakePair.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\ninterface IPancakeRouter01 {\r\n    \r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n\r\n}",
        "fileIndex": 11,
        "fileName": "IPancakeRouter01.sol",
        "id": 52,
        "path": "contracts/IPancakeRouter01.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\nimport \"./IPancakeRouter01.sol\";\r\n\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}",
        "fileIndex": 12,
        "fileName": "IPancakeRouter02.sol",
        "id": 53,
        "path": "contracts/IPancakeRouter02.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}",
        "fileIndex": 13,
        "fileName": "IUniswapV2Factory.sol",
        "id": 54,
        "path": "contracts/IUniswapV2Factory.sol"
      },
      {
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {IPancakeRouter02} from \"./IPancakeRouter02.sol\";\nimport {IPancakePair} from \"./IPancakePair.sol\";\nimport {IUniswapV2Factory} from './IUniswapV2Factory.sol';\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {_GPC, _ROUTER,_WBNB,_USDC,_USDT,DEAD_WALLET} from \"./Const.sol\";\nimport \"./IMSC.sol\";\n\ncontract MorningStar is Ownable,ReentrancyGuard{\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n\n    event BindReferral(address indexed user,address parent);\n    event AddressUpdated(address indexed addr);\n\n    event Staked(\n        address indexed user,\n        uint256 star,\n        uint256 usdt,\n        uint256 price,\n        uint256 timestamp\n    );\n\n    event UnStaked(\n        address indexed user,\n        uint256 star,\n        uint256 price,\n        uint256 timestamp\n    );\n\n    event UnstackMirror(\n        address indexed user,\n        uint256 totalSupply,\n        uint256 balance,\n        uint256 vip,\n        uint256 total,\n        uint256 tag,\n        uint256 dync,\n        uint256 star,\n        uint256 staticAmount,\n        uint256 dynamicAmount,\n        uint256 msc,\n        uint256 price,\n        uint256 timestamp\n    );\n\n    event RewardPaid(\n        address indexed user,\n        uint256 reward,\n        uint40 timestamp,\n        uint256 index\n    );\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event ExpireBurn(address indexed user, uint256 amount, uint256 price, uint256 timestamp);\n    event BatchExpireBurn(uint256 processedCount, uint256 currentIndex, uint256 timestamp);\n\n\n\n  \n\n    struct StarRecord{\n        uint256 id;\n        uint256 star;\n        uint256 timestamp;\n        uint256 starType;\n        uint256 sign;  // 1 0 \n    } \n\n\n    struct WithdrawRecord{\n        uint256 id;\n        uint256 star;\n        uint256 msc;\n        uint256 timestamp;\n    }\n\n    // \n    // 1000U \n    uint256 public constant  LEVEL_1 = 1000 ether;\n    uint256 public constant LEVEL_1_RATE = 200;\n    // 10000U\n    uint256 public constant  LEVEL_2 = 10000 ether;\n    uint256 public constant LEVEL_2_RATE = 250;\n\n    uint256 public constant LEVEL_3_RATE = 300;\n\n    uint256 public constant MAX_PRICE_LENGTH = 100;\n\n    uint256 public constant REDIRECT = 5;\n\n    uint256 public constant BURN_MSC = 10;\n\n    uint256 public constant PER_DAY_RELEASE = 1;\n\n    uint256 public constant  V1_STAR = 10000 ether;\n    uint256 public constant V1 = 5;\n\n\n    uint256 public constant  V2_STAR = 50000 ether;\n    uint256 public constant V2 = 10;\n\n    uint256 public constant  V3_STAR = 200000 ether;\n    uint256 public constant V3 = 15;\n\n    uint256 public constant  V4_STAR = 1000000 ether;\n    uint256 public constant V4 = 20;\n\n    uint256 public constant  V5_STAR = 5000000 ether;\n    uint256 public constant V5 = 25;\n\n    uint256 public constant UNSTAKE_COLD_TIME = 24 hours; \n    uint256 public constant MAX_UNSTAKE_TIME = 180 days;\n\n    uint8 public constant decimals = 18;\n    string public constant name = \"MORNING STAR STAKE\";\n    string public constant symbol = \"MSCST\";\n \n    IPancakeRouter02 internal uniswapV2Router;\n    IERC20 internal gpc;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balances;\n\n    mapping(address=>uint256) public totalStars;\n    mapping(address=>uint256) public releaseStars;\n    mapping(address=>uint256) public teamTotalInvestValue;\n    mapping(address=>uint256) public unstakeTime;\n    mapping(address=>uint256) public teamTotalCount;\n    mapping(address=>uint256) public lastProfits;\n    mapping(address=>StarRecord[]) public starRecords;\n    mapping(address=>WithdrawRecord[]) public withdrawRecords;\n    mapping(address=>bool) public joinFlag;\n    mapping(address=>uint256) public joinTime;\n\n    address[] public joinedAddress;\n    uint256 public expireIndex;\n    uint256 public  constant MAX_CIRCLE=100;\n    uint256 public immutable D_MAX=30;\n\n\n    mapping(address=>address[]) internal refferals;\n    mapping(address=>address) internal belongTo;\n    uint256 internal nonce;\n\n    uint256 internal nonceWithdraw;\n    address public msc;\n    address public marketAddress;\n    address public profit;\n    address public rootAdd;\n    address public uniswapV2PairGpc;\n\n\n    constructor(address _profit_,address _rootAdd){\n       \n        profit = _profit_;\n        rootAdd = _rootAdd;\n\n        bindReferral(address(this),rootAdd);\n\n        gpc = IERC20(_GPC);\n        uniswapV2Router = IPancakeRouter02(_ROUTER);\n        gpc.forceApprove( _ROUTER, type(uint256).max);\n\n        IERC20(_USDT).forceApprove( _ROUTER, type(uint256).max);\n\n        uniswapV2PairGpc = \n            IUniswapV2Factory(uniswapV2Router.factory()).getPair(\n                _GPC,\n                uniswapV2Router.WETH()\n            );\n        \n    }\n\n    function setMsc(address _msc_) public virtual onlyOwner{\n        require(_msc_ != address(0), \"Invalid address\");\n        msc = _msc_;\n        IERC20(msc).forceApprove( _ROUTER, type(uint256).max);\n        emit AddressUpdated(_msc_);\n    }\n\n\n    function balanceOf(address account)\n        external\n        view\n        returns (uint256){\n        return balances[account];\n    }\n\n   \n    function getReferral(address _address)public virtual view returns(address){\n        return belongTo[_address];\n    }\n\n    function isBindReferral(address _address) public virtual view returns(bool){\n        return belongTo[_address] !=address(0);\n    }\n\n    function getReferralCount(address _address) external virtual view returns(uint256){\n        return refferals[_address].length;\n    }\n\n    function bindReferral(address _referral,address _user) public virtual{\n        if(_referral == getRootAddress()){\n            // \n            require(rootAdd==_user,'need root');\n        }else{\n            require(isBindReferral(_referral) ,'referral must  binded');\n        }\n        require(!isBindReferral(_user),'user is binded');\n        \n        refferals[_referral].push(_user);\n        belongTo[_user] = _referral;\n        joinTime[_user] = block.timestamp;\n        joinedAddress.push(_user);\n\n        address tmp = _user;\n        uint256 index = 0;\n        while(true){\n            address parent = getReferral(tmp);\n            if(parent==address(this)){\n                break;\n            }\n            index++;\n            teamTotalCount[parent] ++;\n            tmp = parent;\n        }\n\n\n        emit BindReferral(_user, _referral);\n\n    }\n\n    function getReferrals(address _address) public virtual view returns(address[] memory){\n        return refferals[_address];\n    }\n\n    function getRootAddress() public view returns(address){\n        return address(this);\n    }\n\n    \n\n    function unstake(address user) external nonReentrant{\n        require(block.timestamp - unstakeTime[user] >= UNSTAKE_COLD_TIME,'must at least 24 hours');\n       \n        // \n        uint256 price = IMSC(msc).mscPrice();\n        uint256 balance = IERC20(msc).balanceOf(address(this));\n\n\n        uint256 tag = balance*price*25/totalSupply/1e18;\n        uint256 userStar = balances[user];\n        uint256 dycn = 8 *  10000;\n        if(tag < 20){\n            dycn = balance * 10000 * 1000 * PER_DAY_RELEASE * price / totalSupply /100 /1e18;\n        }\n       \n        uint256 staticAmount  = dycn * userStar /1000 /10000;\n        \n        (,uint256 totalStar,,uint256 vip,) = getUserVip(user);\n        uint256 dynamicAmount = 0;\n\n        if(vip == 1){\n            dynamicAmount = dycn * totalStar  * V1 / 100 /1000 /10000 ;\n        }else if(vip==2){\n            dynamicAmount = dycn * totalStar  * V2 / 100 /1000 /10000;\n        }else if(vip==3){\n            dynamicAmount = dycn * totalStar  * V3 / 100/1000 / 10000;\n        }else if(vip==4){\n            dynamicAmount = dycn * totalStar  * V4 / 100/1000 / 10000;\n        }else if(vip==5){\n            dynamicAmount = dycn * totalStar  * V5 / 100/1000 / 10000;\n        }\n        uint256 totalAmount = staticAmount + dynamicAmount;\n        \n\n      \n        lastProfits[user] = totalAmount;\n        unstakeTime[user]=block.timestamp;\n        uint256 totalMsc = totalAmount * 1e18 / price;\n        emit UnstackMirror(\n             user,\n             totalSupply,\n             balance,\n             vip,\n             totalStar,\n             tag,\n               dycn,\n               totalAmount,\n              staticAmount,\n         dynamicAmount,\n         totalMsc,\n         price,\n         block.timestamp\n    );\n      burn(user,totalAmount,price,3);\n\n        nonceWithdraw++;\n        withdrawRecords[user].push(WithdrawRecord({\n              id:nonceWithdraw,\n              star: totalAmount,\n              msc: totalMsc,\n             timestamp:block.timestamp\n        }));\n        uint256 totalFee = totalMsc / 10;\n        IERC20(msc).safeTransfer(user,totalMsc-totalFee);\n\n        releaseReward(totalFee);\n        \n        // \n        burnExpireAll();\n\n    }\n\n    function releaseReward(uint256 fee) public{\n\n        uint256 burnFee = fee/2;\n        uint256 profitFee = fee-burnFee;\n        swapTokenForGPC(burnFee,uniswapV2PairGpc);\n        IPancakePair(uniswapV2PairGpc).sync(); \n        IERC20(msc).safeTransfer(profit,profitFee);   \n    }\n    \n    function burnExpire(address currentUser,uint256 price) internal{\n        if (currentUser == address(0)) return; // \n        if (unstakeTime[currentUser] == 0) return; // \n        if (balances[currentUser] == 0) return; // \n        // 2. \n        uint256 timeElapsed = block.timestamp - unstakeTime[currentUser];\n        if (timeElapsed > MAX_UNSTAKE_TIME) {\n            uint256 burnAmount = balances[currentUser];\n            // \n            burn(currentUser, burnAmount, price, 4);\n            // \n        }\n    }\n    \n\n    function burnExpireAll() public {\n        \n        // 1. \n        uint256 totalUsers = joinedAddress.length;\n        if (totalUsers == 0) {\n            emit BatchExpireBurn(0, expireIndex, block.timestamp);\n            return;\n        }\n\n        // 2. MSC\n        uint256 price = IMSC(msc).mscPrice();\n        require(price > 0, \"Staking: MSC price is zero\"); // \n\n        // 3. Gas\n        uint256 i = 0;\n        uint256 processedCount = 0;\n        while (i < MAX_CIRCLE) {\n            // \n            address currentUser = joinedAddress[expireIndex % totalUsers];\n            // \n            burnExpire(currentUser, price);\n\n            // 4. \n            expireIndex = (expireIndex + 1) % totalUsers; // \n            i++;\n            processedCount++;\n\n            // 5. \n            if (expireIndex == 0) break;\n        }\n\n        // 6. \n        emit BatchExpireBurn(processedCount, expireIndex, block.timestamp);\n       \n    }\n\n    receive() external payable {\n        dealReceive();\n    }\n\n      //  receive fallback\n    fallback() external payable {\n        //  BNB\n        dealReceive();\n    }\n\n    function dealReceive() internal view{\n        require(msg.sender==address(this),'not support');\n    }\n\n\n    function staked(address user,uint256 amount) external nonReentrant{\n        require(isBindReferral(user),'need bind');\n        IERC20(msc).safeTransferFrom(msg.sender,address(this),amount);\n        uint256 usdt = amount *  IMSC(msc).mscPrice()/1e18;   \n        addStar(user,usdt);\n        uint256 burnAmount = amount* BURN_MSC/MAX_PRICE_LENGTH;\n        IERC20(msc).safeTransfer(DEAD_WALLET,burnAmount);\n    }\n\n    function addStar(address user,uint256 usdt) internal{\n\n        uint256 star = 0;\n        if(usdt < LEVEL_1){\n            star = usdt*LEVEL_1_RATE/MAX_PRICE_LENGTH;\n        }else if(usdt < LEVEL_2){\n            star = usdt*LEVEL_2_RATE/MAX_PRICE_LENGTH;\n        }else{\n            star = usdt*LEVEL_3_RATE/MAX_PRICE_LENGTH;\n        }\n        uint256 price=  IMSC(msc).mscPrice();\n        mint(user,star,usdt,price,1);\n        // \n        uint256 tui = star * REDIRECT/MAX_PRICE_LENGTH;\n        address parent = getReferral(user);\n        if(parent != address(this)){\n            mint(parent,tui,0,price,2);\n        }\n      \n        if(!joinFlag[user]){\n            unstakeTime[user]=block.timestamp; \n            joinFlag[user] = true;\n        }\n        burnExpireAll();\n    }\n\n\n    function stakedUsdt(address user,uint256 usdt) external nonReentrant{\n        require(isBindReferral(user),'need bind');\n        IERC20(_USDT).safeTransferFrom(msg.sender,address(this),usdt);    \n        uint256 burnAmount = usdt* BURN_MSC/MAX_PRICE_LENGTH/100;\n        swapUSDTForToken(burnAmount,DEAD_WALLET);\n        swapUSDTForToken(usdt-burnAmount,address(this));\n        addStar(user,usdt);\n       \n    }\n\n   \n\n    function swapUSDTForToken(uint256 tokenAmount, address to) internal virtual returns(bool){\n        unchecked {\n            address[] memory path = new address[](4);\n            path[0] = _USDT;\n            path[1] = _WBNB;\n            path[2] = _GPC;\n            path[3] = msc;\n            uniswapV2Router\n                .swapExactTokensForTokensSupportingFeeOnTransferTokens(\n                    tokenAmount,\n                    0, // accept any amount of ETH\n                    path,\n                    to,\n                    block.timestamp+300\n            );\n            return true;\n        }\n    }\n\n\n    function swapTokenForGPC(uint256 tokenAmount, address to) internal virtual returns(bool){\n        unchecked {\n            address[] memory path = new address[](2);\n            path[0] = msc;\n            path[1] = _GPC;\n            \n            uniswapV2Router\n                .swapExactTokensForTokensSupportingFeeOnTransferTokens(\n                    tokenAmount,\n                    0, // accept any amount of ETH\n                    path,\n                    to,\n                    block.timestamp+300\n            );\n            return true;\n        }\n    }\n \n\n    function burn(address sender,uint256 _star,uint256 _price,uint256 starType) internal{\n        address tmp = sender;\n        uint256 index = 0;\n        while(true){\n            address parent = getReferral(tmp);\n            if(parent==address(this)){\n                break;\n            }\n            if(index==D_MAX){\n                break;\n            }  \n            index++;    \n            teamTotalInvestValue[parent] -= _star;\n            tmp = parent;\n        }\n        totalSupply -= _star;\n        balances[sender] -= _star;\n        teamTotalInvestValue[sender] -=_star;\n        releaseStars[sender] +=_star;\n        nonce++;\n        starRecords[sender].push(StarRecord({\n            id:nonce,\n            star: _star ,\n            timestamp:block.timestamp,\n            starType: starType,\n            sign:0\n        }));\n        if(balances[sender]==0){\n            delete unstakeTime[sender]; \n        }\n        emit Transfer(sender,address(0),  _star);\n        emit UnStaked(sender, _star,_price,block.timestamp);\n    }\n\n\n    function mint(address sender, uint256 _star,uint256 _usdt,uint256 _price,uint256 starType) private {\n        \n        address tmp = sender;\n        uint256 index = 0;\n        while(true){\n            address parent = getReferral(tmp);\n            if(parent==address(this)){\n                break;\n            }\n            if(index==D_MAX){\n                break;\n            }\n            teamTotalInvestValue[parent] += _star;\n            tmp = parent;\n            index++;\n\n        }\n        totalSupply += _star;\n        balances[sender] += _star;\n        totalStars[sender] +=_star;\n        teamTotalInvestValue[sender] += _star;\n        nonce++;\n        starRecords[sender].push(StarRecord({\n            id:nonce,\n            star: _star ,\n            timestamp:block.timestamp,\n            starType: starType,\n            sign:1\n        }));\n        emit Transfer(address(0), sender, _star);\n        emit Staked(sender, _star,_usdt,_price,block.timestamp);\n    }\n\n    function getStarRecordCounts(address user) external view returns(uint256){\n        return starRecords[user].length;\n    }\n\n    \n       /**\n     * @dev \n     * @param user \n     * @param length \n     * @return records length\n     */\n    function getStarRecords(address user, uint256 length) external view returns (StarRecord[] memory) {\n        // 1. \n        uint256 totalRecords = starRecords[user].length;\n        \n        // \n        if (totalRecords == 0) {\n            return new StarRecord[](0);\n        }\n\n        // 2. \n        uint256 returnLength = length > totalRecords ? totalRecords : length;\n        \n        // 3. returnLength\n        StarRecord[] memory records = new StarRecord[](returnLength);\n        \n        // 4.  + uint256\n        // i0returnLength-1returnLength\n        for (uint256 i = 0; i < returnLength; i++) {\n            //  =  - 1 - \n            uint256 recordIndex = totalRecords - 1 - i;\n            records[i] = starRecords[user][recordIndex];\n        }\n\n        return records;\n    }\n    \n\n    function getUnStackedRecordCounts(address user) external view returns(uint256){\n        return withdrawRecords[user].length;\n    }\n\n    function getUnStackedRecords(address user,uint256 length) external view returns(WithdrawRecord[] memory){\n         // 1. \n        uint256 totalRecords = withdrawRecords[user].length;\n        \n        // \n        if (totalRecords == 0) {\n            return new WithdrawRecord[](0);\n        }\n\n        // 2. \n        uint256 returnLength = length > totalRecords ? totalRecords : length;\n        \n        // 3. returnLength\n        WithdrawRecord[] memory records = new WithdrawRecord[](returnLength);\n        \n        // 4. uint256\n        // i - returnLength + 1\n        for (uint256 i = 0; i < returnLength; i++) {\n            // totalRecords - 1 - i\n            uint256 recordIndex = totalRecords - 1 - i;\n            records[i] = withdrawRecords[user][recordIndex];\n        }\n\n        return records;\n    \n    }\n\n    function getUserVip(address user) public view returns(uint256,uint256,uint256,uint256,uint256){\n        address[] memory referrals = getReferrals(user);\n        address maxReferral = address(0);\n        uint256 maxStar = 0;\n        for(uint256 i=0;i<referrals.length;i++){\n            if(teamTotalInvestValue[referrals[i]]> maxStar){\n                maxReferral = referrals[i];\n                maxStar = teamTotalInvestValue[maxReferral];\n            }\n        }\n        uint256 totalStar = 0;\n        for(uint256 i=0;i<referrals.length;i++){\n            if(referrals[i] !=maxReferral ){\n               totalStar+=teamTotalInvestValue[referrals[i]];\n            }\n        }\n        uint256 realStar = totalStar;\n        \n        if(realStar >= balances[user] * 5){\n            realStar = balances[user] * 5;\n        }\n        uint256 vip =0;\n        if(realStar>=V5_STAR){\n            vip = 5;\n        }else if(realStar>=V4_STAR){\n            vip = 4;\n        }else if(realStar>=V3_STAR){\n            vip = 3;\n        }else if(realStar>=V2_STAR){\n            vip = 2;\n        }else if(realStar>=V1_STAR){\n            vip = 1;\n\n        }\n        return (teamTotalInvestValue[user]-balances[user],realStar,maxStar,vip,totalStar);\n    }\n\n   \n\n}",
        "fileIndex": 14,
        "fileName": "MorningStar.sol",
        "id": 55,
        "path": "contracts/MorningStar.sol"
      }
    ]
  },
  "codeLocationMap": {
    "100": {
      "callCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 40,
        "endLine": 237,
        "fileIndex": 2,
        "sourced": true,
        "startColumn": 14,
        "startLine": 237
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "101": {
      "callCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 10,
        "endLine": 482,
        "fileIndex": 18,
        "sourced": true,
        "startColumn": 28,
        "startLine": 475
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "102": {
      "callCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 59,
        "endLine": 484,
        "fileIndex": 18,
        "sourced": true,
        "startColumn": 14,
        "startLine": 484
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "103": {
      "callCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 71,
        "endLine": 452,
        "fileIndex": 18,
        "sourced": true,
        "startColumn": 14,
        "startLine": 452
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "104": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 73,
        "endLine": 732,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 30,
        "startLine": 732
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 393,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 391
      }
    },
    "106": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 65,
        "endLine": 712,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 47,
        "startLine": 712
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 339,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 335
      }
    },
    "108": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 56,
        "endLine": 735,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 13,
        "startLine": 735
      },
      "defCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 2,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "110": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 64,
        "endLine": 719,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 13,
        "startLine": 719
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 484,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 456
      }
    },
    "116": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 100,
        "endLine": 342,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 45,
        "startLine": 342
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 407,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 403
      }
    },
    "121": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 39,
        "endLine": 530,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 14,
        "startLine": 530
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "122": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 60,
        "endLine": 470,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 20,
        "startLine": 470
      },
      "defCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 2,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "124": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 60,
        "endLine": 471,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 20,
        "startLine": 471
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 393,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 391
      }
    },
    "13": {
      "callCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 484,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 456
      }
    },
    "138": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 38,
        "endLine": 382,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 14,
        "startLine": 382
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "139": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 80,
        "endLine": 483,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 14,
        "startLine": 483
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "141": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 56,
        "endLine": 735,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 13,
        "startLine": 735
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 393,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 391
      }
    },
    "144": {
      "callCodeLocation": {
        "codeHash": "0xc2be4f894c1c91337f977f51694ecd95489fb2a9b55b45a6a33990e32029a3fe",
        "endColumn": 46,
        "endLine": 330,
        "fileIndex": 14,
        "sourced": true,
        "startColumn": 9,
        "startLine": 330
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 497,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 495
      }
    },
    "148": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 56,
        "endLine": 496,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 17,
        "startLine": 496
      },
      "defCodeLocation": {
        "codeHash": "0xb7d84205eaaf83ce7b3940c6beaad6d22790255e34a9a2b486aa8cdfff118fe6",
        "endColumn": 70,
        "endLine": 17,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 17
      }
    },
    "151": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 97,
        "endLine": 496,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 58,
        "startLine": 496
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 393,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 391
      }
    },
    "160": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 38,
        "endLine": 382,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 14,
        "startLine": 382
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "164": {
      "callCodeLocation": {
        "codeHash": "0xc2be4f894c1c91337f977f51694ecd95489fb2a9b55b45a6a33990e32029a3fe",
        "endColumn": 82,
        "endLine": 135,
        "fileIndex": 5,
        "sourced": true,
        "startColumn": 51,
        "startLine": 135
      },
      "defCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 6,
        "endLine": 117,
        "fileIndex": 2,
        "sourced": true,
        "startColumn": 5,
        "startLine": 113
      }
    },
    "176": {
      "callCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 40,
        "endLine": 237,
        "fileIndex": 2,
        "sourced": true,
        "startColumn": 14,
        "startLine": 237
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "177": {
      "callCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 10,
        "endLine": 482,
        "fileIndex": 18,
        "sourced": true,
        "startColumn": 28,
        "startLine": 475
      },
      "defCodeLocation": {
        "codeHash": "0xb89c1b3bdf2cf8827818646bce9a8f6e372885f8c55e5c07acbd307cb133b000",
        "endColumn": 6,
        "endLine": 43,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 26
      }
    },
    "179": {
      "callCodeLocation": {
        "codeHash": "0xb89c1b3bdf2cf8827818646bce9a8f6e372885f8c55e5c07acbd307cb133b000",
        "endColumn": 84,
        "endLine": 36,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 28,
        "startLine": 36
      },
      "defCodeLocation": {
        "codeHash": "0x21842597390c4c6e3c1239e434a682b054bd9548eee5e9b1d6a4482731023c0f",
        "endColumn": 6,
        "endLine": 52,
        "fileIndex": 3,
        "sourced": true,
        "startColumn": 5,
        "startLine": 32
      }
    },
    "181": {
      "callCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 59,
        "endLine": 484,
        "fileIndex": 18,
        "sourced": true,
        "startColumn": 14,
        "startLine": 484
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "182": {
      "callCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 71,
        "endLine": 452,
        "fileIndex": 18,
        "sourced": true,
        "startColumn": 14,
        "startLine": 452
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "183": {
      "callCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      },
      "defCodeLocation": {
        "codeHash": "0xb7d84205eaaf83ce7b3940c6beaad6d22790255e34a9a2b486aa8cdfff118fe6",
        "endColumn": 70,
        "endLine": 17,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 17
      }
    },
    "186": {
      "callCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 634,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 621
      }
    },
    "187": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 103,
        "endLine": 302,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 43,
        "startLine": 302
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 339,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 335
      }
    },
    "189": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 108,
        "endLine": 21,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 45,
        "startLine": 21
      },
      "defCodeLocation": {
        "codeHash": "0xb7d84205eaaf83ce7b3940c6beaad6d22790255e34a9a2b486aa8cdfff118fe6",
        "endColumn": 6,
        "endLine": 65,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 48
      }
    },
    "19": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 100,
        "endLine": 342,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 45,
        "startLine": 342
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 407,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 403
      }
    },
    "196": {
      "callCodeLocation": {
        "codeHash": "0xb7d84205eaaf83ce7b3940c6beaad6d22790255e34a9a2b486aa8cdfff118fe6",
        "endColumn": 32,
        "endLine": 62,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 62
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "197": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 14,
        "endLine": 604,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 13,
        "startLine": 602
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 484,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 456
      }
    },
    "203": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 100,
        "endLine": 342,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 45,
        "startLine": 342
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 407,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 403
      }
    },
    "208": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 39,
        "endLine": 530,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 14,
        "startLine": 530
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "209": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 60,
        "endLine": 470,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 20,
        "startLine": 470
      },
      "defCodeLocation": {
        "codeHash": "0xb7d84205eaaf83ce7b3940c6beaad6d22790255e34a9a2b486aa8cdfff118fe6",
        "endColumn": 70,
        "endLine": 17,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 17
      }
    },
    "211": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 60,
        "endLine": 471,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 20,
        "startLine": 471
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 393,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 391
      }
    },
    "220": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 38,
        "endLine": 382,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 14,
        "startLine": 382
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "221": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 80,
        "endLine": 483,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 14,
        "startLine": 483
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "224": {
      "callCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 407,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 403
      }
    },
    "229": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 39,
        "endLine": 530,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 14,
        "startLine": 530
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "230": {
      "callCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      },
      "defCodeLocation": {
        "codeHash": "0xb7d84205eaaf83ce7b3940c6beaad6d22790255e34a9a2b486aa8cdfff118fe6",
        "endColumn": 70,
        "endLine": 17,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 17
      }
    },
    "232": {
      "callCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      },
      "defCodeLocation": {
        "codeHash": "0xb7d84205eaaf83ce7b3940c6beaad6d22790255e34a9a2b486aa8cdfff118fe6",
        "endColumn": 6,
        "endLine": 46,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 44
      }
    },
    "237": {
      "callCodeLocation": {
        "codeHash": "0xb7d84205eaaf83ce7b3940c6beaad6d22790255e34a9a2b486aa8cdfff118fe6",
        "endColumn": 32,
        "endLine": 62,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 62
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "238": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 60,
        "endLine": 470,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 20,
        "startLine": 470
      },
      "defCodeLocation": {
        "codeHash": "0x4654d519bb3a67b062c0c4ddf0e2623a2d7cbddde0a8460503dd0b4bc995f8a1",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 2,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "24": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 39,
        "endLine": 530,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 14,
        "startLine": 530
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "240": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 60,
        "endLine": 471,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 20,
        "startLine": 471
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 393,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 391
      }
    },
    "25": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 102,
        "endLine": 469,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 30,
        "startLine": 469
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "254": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 38,
        "endLine": 382,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 14,
        "startLine": 382
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "255": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 80,
        "endLine": 483,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 14,
        "startLine": 483
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "257": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 64,
        "endLine": 458,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 51,
        "startLine": 458
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 339,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 335
      }
    },
    "258": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 67,
        "endLine": 468,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 29,
        "startLine": 468
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 344,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 341
      }
    },
    "259": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 75,
        "endLine": 477,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 58,
        "startLine": 477
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "26": {
      "callCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 808,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 799
      }
    },
    "260": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 53,
        "endLine": 477,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 34,
        "startLine": 477
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "261": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 76,
        "endLine": 477,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 34,
        "startLine": 477
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 99,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 97
      }
    },
    "262": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 75,
        "endLine": 478,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 58,
        "startLine": 478
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "263": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 53,
        "endLine": 478,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 34,
        "startLine": 478
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "264": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 76,
        "endLine": 478,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 34,
        "startLine": 478
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 99,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 97
      }
    },
    "265": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 89,
        "endLine": 479,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 59,
        "startLine": 479
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "266": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 103,
        "endLine": 479,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 59,
        "startLine": 479
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "267": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 55,
        "endLine": 479,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 17,
        "startLine": 479
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "268": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 58,
        "endLine": 482,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 482
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 383,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 370
      }
    },
    "269": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 69,
        "endLine": 376,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 42,
        "startLine": 376
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 242,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 240
      }
    },
    "270": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 86,
        "endLine": 376,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 42,
        "startLine": 376
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 247,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 245
      }
    },
    "271": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 69,
        "endLine": 377,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 42,
        "startLine": 377
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 242,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 240
      }
    },
    "272": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 86,
        "endLine": 377,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 42,
        "startLine": 377
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 247,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 245
      }
    },
    "273": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 37,
        "endLine": 404,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 25,
        "startLine": 404
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 17,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 15
      }
    },
    "274": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 36,
        "endLine": 405,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 405
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 490,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 478
      }
    },
    "275": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 33,
        "endLine": 489,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 489
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 531,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 499
      }
    },
    "276": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 37,
        "endLine": 805,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 25,
        "startLine": 805
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 17,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 15
      }
    },
    "277": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 40,
        "endLine": 806,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 806
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 584,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 578
      }
    },
    "278": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 46,
        "endLine": 583,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 583
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 619,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 603
      }
    },
    "279": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 83,
        "endLine": 678,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 34,
        "startLine": 678
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 296,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 288
      }
    },
    "280": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 70,
        "endLine": 289,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 44,
        "startLine": 289
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 285,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 281
      }
    },
    "281": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 10,
        "endLine": 731,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 729
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 23,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 19
      }
    },
    "282": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 53,
        "endLine": 733,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 733
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 721,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 704
      }
    },
    "283": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 73,
        "endLine": 707,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 33,
        "startLine": 707
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 285,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 281
      }
    },
    "284": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 92,
        "endLine": 708,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 46,
        "startLine": 708
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 296,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 288
      }
    },
    "285": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 70,
        "endLine": 289,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 44,
        "startLine": 289
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 285,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 281
      }
    },
    "286": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 75,
        "endLine": 735,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 13,
        "startLine": 735
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 209,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 207
      }
    },
    "287": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 97,
        "endLine": 715,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 28,
        "startLine": 715
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 321,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 314
      }
    },
    "288": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 50,
        "endLine": 317,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 32,
        "startLine": 317
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 213,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 211
      }
    },
    "289": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 57,
        "endLine": 318,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 26,
        "startLine": 318
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 213,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 211
      }
    },
    "29": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 49,
        "endLine": 617,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 18,
        "startLine": 617
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "290": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 48,
        "endLine": 319,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 28,
        "startLine": 319
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 213,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 211
      }
    },
    "291": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 69,
        "endLine": 319,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 28,
        "startLine": 319
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 205,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 203
      }
    },
    "292": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 75,
        "endLine": 735,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 13,
        "startLine": 735
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 209,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 207
      }
    },
    "293": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 39,
        "endLine": 462,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 27,
        "startLine": 462
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 17,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 15
      }
    },
    "294": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 46,
        "endLine": 463,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 463
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 647,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 629
      }
    },
    "295": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 61,
        "endLine": 634,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 36,
        "startLine": 634
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 419,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 412
      }
    },
    "296": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 35,
        "endLine": 464,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 464
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 490,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 478
      }
    },
    "297": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 33,
        "endLine": 489,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 489
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 531,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 499
      }
    },
    "298": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 64,
        "endLine": 458,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 51,
        "startLine": 458
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 339,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 335
      }
    },
    "299": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 67,
        "endLine": 467,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 29,
        "startLine": 467
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 344,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 341
      }
    },
    "30": {
      "callCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      },
      "defCodeLocation": {
        "codeHash": "0xb7d84205eaaf83ce7b3940c6beaad6d22790255e34a9a2b486aa8cdfff118fe6",
        "endColumn": 6,
        "endLine": 42,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 38
      }
    },
    "300": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 75,
        "endLine": 477,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 58,
        "startLine": 477
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "301": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 53,
        "endLine": 477,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 34,
        "startLine": 477
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "302": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 76,
        "endLine": 477,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 34,
        "startLine": 477
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 99,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 97
      }
    },
    "303": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 75,
        "endLine": 478,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 58,
        "startLine": 478
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "304": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 53,
        "endLine": 478,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 34,
        "startLine": 478
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "305": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 76,
        "endLine": 478,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 34,
        "startLine": 478
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 99,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 97
      }
    },
    "306": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 89,
        "endLine": 479,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 59,
        "startLine": 479
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "307": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 103,
        "endLine": 479,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 59,
        "startLine": 479
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "308": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 55,
        "endLine": 479,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 17,
        "startLine": 479
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "309": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 58,
        "endLine": 482,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 482
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 383,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 370
      }
    },
    "310": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 69,
        "endLine": 376,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 42,
        "startLine": 376
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 242,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 240
      }
    },
    "311": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 86,
        "endLine": 376,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 42,
        "startLine": 376
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 247,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 245
      }
    },
    "312": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 69,
        "endLine": 377,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 42,
        "startLine": 377
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 242,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 240
      }
    },
    "313": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 86,
        "endLine": 377,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 42,
        "startLine": 377
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 247,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 245
      }
    },
    "314": {
      "callCodeLocation": {
        "codeHash": "0xb7d84205eaaf83ce7b3940c6beaad6d22790255e34a9a2b486aa8cdfff118fe6",
        "endColumn": 50,
        "endLine": 45,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 16,
        "startLine": 45
      },
      "defCodeLocation": {
        "codeHash": "0xb7d84205eaaf83ce7b3940c6beaad6d22790255e34a9a2b486aa8cdfff118fe6",
        "endColumn": 6,
        "endLine": 65,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 48
      }
    },
    "315": {
      "callCodeLocation": {
        "codeHash": "0xc2be4f894c1c91337f977f51694ecd95489fb2a9b55b45a6a33990e32029a3fe",
        "endColumn": 2,
        "endLine": 663,
        "fileIndex": 14,
        "sourced": true,
        "startColumn": 1,
        "startLine": 15
      },
      "defCodeLocation": {
        "codeHash": "0xc2be4f894c1c91337f977f51694ecd95489fb2a9b55b45a6a33990e32029a3fe",
        "endColumn": 6,
        "endLine": 332,
        "fileIndex": 14,
        "sourced": true,
        "startColumn": 5,
        "startLine": 325
      }
    },
    "316": {
      "callCodeLocation": {
        "codeHash": "0xc2be4f894c1c91337f977f51694ecd95489fb2a9b55b45a6a33990e32029a3fe",
        "endColumn": 50,
        "endLine": 331,
        "fileIndex": 14,
        "sourced": true,
        "startColumn": 41,
        "startLine": 331
      },
      "defCodeLocation": {
        "codeHash": "0xc2be4f894c1c91337f977f51694ecd95489fb2a9b55b45a6a33990e32029a3fe",
        "endColumn": 6,
        "endLine": 28,
        "fileIndex": 4,
        "sourced": true,
        "startColumn": 5,
        "startLine": 26
      }
    },
    "317": {
      "callCodeLocation": {
        "codeHash": "0xc2be4f894c1c91337f977f51694ecd95489fb2a9b55b45a6a33990e32029a3fe",
        "endColumn": 104,
        "endLine": 35,
        "fileIndex": 4,
        "sourced": true,
        "startColumn": 36,
        "startLine": 35
      },
      "defCodeLocation": {
        "codeHash": "0xc2be4f894c1c91337f977f51694ecd95489fb2a9b55b45a6a33990e32029a3fe",
        "endColumn": 6,
        "endLine": 124,
        "fileIndex": 4,
        "sourced": true,
        "startColumn": 5,
        "startLine": 117
      }
    },
    "318": {
      "callCodeLocation": {
        "codeHash": "0xc2be4f894c1c91337f977f51694ecd95489fb2a9b55b45a6a33990e32029a3fe",
        "endColumn": 85,
        "endLine": 136,
        "fileIndex": 5,
        "sourced": true,
        "startColumn": 16,
        "startLine": 136
      },
      "defCodeLocation": {
        "codeHash": "0xc2be4f894c1c91337f977f51694ecd95489fb2a9b55b45a6a33990e32029a3fe",
        "endColumn": 6,
        "endLine": 211,
        "fileIndex": 5,
        "sourced": true,
        "startColumn": 5,
        "startLine": 195
      }
    },
    "319": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 83,
        "endLine": 678,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 34,
        "startLine": 678
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 296,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 288
      }
    },
    "32": {
      "callCodeLocation": {
        "codeHash": "0xb7d84205eaaf83ce7b3940c6beaad6d22790255e34a9a2b486aa8cdfff118fe6",
        "endColumn": 39,
        "endLine": 40,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 40
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "320": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 70,
        "endLine": 289,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 44,
        "startLine": 289
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 285,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 281
      }
    },
    "321": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 10,
        "endLine": 731,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 729
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 23,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 19
      }
    },
    "322": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 53,
        "endLine": 733,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 733
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 721,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 704
      }
    },
    "323": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 73,
        "endLine": 707,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 33,
        "startLine": 707
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 285,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 281
      }
    },
    "324": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 92,
        "endLine": 708,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 46,
        "startLine": 708
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 296,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 288
      }
    },
    "325": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 70,
        "endLine": 289,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 44,
        "startLine": 289
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 285,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 281
      }
    },
    "326": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 75,
        "endLine": 735,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 13,
        "startLine": 735
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 209,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 207
      }
    },
    "327": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 97,
        "endLine": 715,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 28,
        "startLine": 715
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 321,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 314
      }
    },
    "328": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 50,
        "endLine": 317,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 32,
        "startLine": 317
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 213,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 211
      }
    },
    "329": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 57,
        "endLine": 318,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 26,
        "startLine": 318
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 213,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 211
      }
    },
    "33": {
      "callCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 393,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 391
      }
    },
    "330": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 48,
        "endLine": 319,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 28,
        "startLine": 319
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 213,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 211
      }
    },
    "331": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 69,
        "endLine": 319,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 28,
        "startLine": 319
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 205,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 203
      }
    },
    "332": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 75,
        "endLine": 735,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 13,
        "startLine": 735
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 209,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 207
      }
    },
    "333": {
      "callCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 35,
        "endLine": 161,
        "fileIndex": 2,
        "sourced": true,
        "startColumn": 29,
        "startLine": 161
      },
      "defCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 6,
        "endLine": 219,
        "fileIndex": 18,
        "sourced": true,
        "startColumn": 5,
        "startLine": 135
      }
    },
    "334": {
      "callCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 54,
        "endLine": 192,
        "fileIndex": 18,
        "sourced": true,
        "startColumn": 48,
        "startLine": 192
      },
      "defCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 6,
        "endLine": 240,
        "fileIndex": 2,
        "sourced": true,
        "startColumn": 5,
        "startLine": 222
      }
    },
    "335": {
      "callCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 62,
        "endLine": 216,
        "fileIndex": 18,
        "sourced": true,
        "startColumn": 56,
        "startLine": 216
      },
      "defCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 6,
        "endLine": 453,
        "fileIndex": 18,
        "sourced": true,
        "startColumn": 5,
        "startLine": 445
      }
    },
    "336": {
      "callCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 70,
        "endLine": 451,
        "fileIndex": 18,
        "sourced": true,
        "startColumn": 38,
        "startLine": 451
      },
      "defCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 6,
        "endLine": 486,
        "fileIndex": 18,
        "sourced": true,
        "startColumn": 5,
        "startLine": 463
      }
    },
    "337": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 64,
        "endLine": 458,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 51,
        "startLine": 458
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 339,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 335
      }
    },
    "338": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 67,
        "endLine": 468,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 29,
        "startLine": 468
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 344,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 341
      }
    },
    "339": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 75,
        "endLine": 477,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 58,
        "startLine": 477
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "340": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 53,
        "endLine": 477,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 34,
        "startLine": 477
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "341": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 76,
        "endLine": 477,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 34,
        "startLine": 477
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 99,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 97
      }
    },
    "342": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 75,
        "endLine": 478,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 58,
        "startLine": 478
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "343": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 53,
        "endLine": 478,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 34,
        "startLine": 478
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "344": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 76,
        "endLine": 478,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 34,
        "startLine": 478
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 99,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 97
      }
    },
    "345": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 89,
        "endLine": 479,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 59,
        "startLine": 479
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "346": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 103,
        "endLine": 479,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 59,
        "startLine": 479
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "347": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 55,
        "endLine": 479,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 17,
        "startLine": 479
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "348": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 58,
        "endLine": 482,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 482
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 383,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 370
      }
    },
    "349": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 69,
        "endLine": 376,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 42,
        "startLine": 376
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 242,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 240
      }
    },
    "35": {
      "callCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 738,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 722
      }
    },
    "350": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 86,
        "endLine": 376,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 42,
        "startLine": 376
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 247,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 245
      }
    },
    "351": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 69,
        "endLine": 377,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 42,
        "startLine": 377
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 242,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 240
      }
    },
    "352": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 86,
        "endLine": 377,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 42,
        "startLine": 377
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 247,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 245
      }
    },
    "353": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 37,
        "endLine": 404,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 25,
        "startLine": 404
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 17,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 15
      }
    },
    "354": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 36,
        "endLine": 405,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 405
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 490,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 478
      }
    },
    "355": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 33,
        "endLine": 489,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 489
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 531,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 499
      }
    },
    "356": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 118,
        "endLine": 496,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 496
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 383,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 370
      }
    },
    "357": {
      "callCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 36,
        "endLine": 115,
        "fileIndex": 2,
        "sourced": true,
        "startColumn": 30,
        "startLine": 115
      },
      "defCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 6,
        "endLine": 219,
        "fileIndex": 18,
        "sourced": true,
        "startColumn": 5,
        "startLine": 135
      }
    },
    "358": {
      "callCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 54,
        "endLine": 192,
        "fileIndex": 18,
        "sourced": true,
        "startColumn": 48,
        "startLine": 192
      },
      "defCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 6,
        "endLine": 240,
        "fileIndex": 2,
        "sourced": true,
        "startColumn": 5,
        "startLine": 222
      }
    },
    "359": {
      "callCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 62,
        "endLine": 216,
        "fileIndex": 18,
        "sourced": true,
        "startColumn": 56,
        "startLine": 216
      },
      "defCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 6,
        "endLine": 453,
        "fileIndex": 18,
        "sourced": true,
        "startColumn": 5,
        "startLine": 445
      }
    },
    "36": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 108,
        "endLine": 21,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 45,
        "startLine": 21
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 466,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 457
      }
    },
    "360": {
      "callCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 70,
        "endLine": 451,
        "fileIndex": 18,
        "sourced": true,
        "startColumn": 38,
        "startLine": 451
      },
      "defCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 6,
        "endLine": 486,
        "fileIndex": 18,
        "sourced": true,
        "startColumn": 5,
        "startLine": 463
      }
    },
    "361": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 72,
        "endLine": 628,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 19,
        "startLine": 628
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 352,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 344
      }
    },
    "362": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 91,
        "endLine": 338,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 49,
        "startLine": 338
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 304,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 299
      }
    },
    "363": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 55,
        "endLine": 300,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 29,
        "startLine": 300
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 285,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 281
      }
    },
    "364": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 41,
        "endLine": 301,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 301
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 296,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 288
      }
    },
    "365": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 70,
        "endLine": 289,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 44,
        "startLine": 289
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 285,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 281
      }
    },
    "366": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 88,
        "endLine": 302,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 56,
        "startLine": 302
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 296,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 288
      }
    },
    "367": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 70,
        "endLine": 289,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 44,
        "startLine": 289
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 285,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 281
      }
    },
    "368": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 76,
        "endLine": 350,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 30,
        "startLine": 350
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 330,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 324
      }
    },
    "369": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 50,
        "endLine": 327,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 26,
        "startLine": 327
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 213,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 211
      }
    },
    "370": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 61,
        "endLine": 327,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 26,
        "startLine": 327
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 213,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 211
      }
    },
    "371": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 53,
        "endLine": 328,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 28,
        "startLine": 328
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 209,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 207
      }
    },
    "372": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 61,
        "endLine": 327,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 26,
        "startLine": 327
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 213,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 211
      }
    },
    "373": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 52,
        "endLine": 329,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 20,
        "startLine": 329
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 205,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 203
      }
    },
    "374": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 83,
        "endLine": 678,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 34,
        "startLine": 678
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 296,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 288
      }
    },
    "375": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 70,
        "endLine": 289,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 44,
        "startLine": 289
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 285,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 281
      }
    },
    "376": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 10,
        "endLine": 679,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 677
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 23,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 19
      }
    },
    "377": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 33,
        "endLine": 619,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 619
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 606,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 595
      }
    },
    "378": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 73,
        "endLine": 598,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 33,
        "startLine": 598
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 285,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 281
      }
    },
    "379": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 72,
        "endLine": 602,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 26,
        "startLine": 602
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 296,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 288
      }
    },
    "380": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 70,
        "endLine": 289,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 44,
        "startLine": 289
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 285,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 281
      }
    },
    "381": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 64,
        "endLine": 458,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 51,
        "startLine": 458
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 339,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 335
      }
    },
    "382": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 67,
        "endLine": 468,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 29,
        "startLine": 468
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 344,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 341
      }
    },
    "383": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 75,
        "endLine": 477,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 58,
        "startLine": 477
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "384": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 53,
        "endLine": 477,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 34,
        "startLine": 477
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "385": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 76,
        "endLine": 477,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 34,
        "startLine": 477
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 99,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 97
      }
    },
    "386": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 75,
        "endLine": 478,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 58,
        "startLine": 478
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "387": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 53,
        "endLine": 478,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 34,
        "startLine": 478
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "388": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 76,
        "endLine": 478,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 34,
        "startLine": 478
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 99,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 97
      }
    },
    "389": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 89,
        "endLine": 479,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 59,
        "startLine": 479
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "390": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 103,
        "endLine": 479,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 59,
        "startLine": 479
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "391": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 55,
        "endLine": 479,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 17,
        "startLine": 479
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "392": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 58,
        "endLine": 482,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 482
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 383,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 370
      }
    },
    "393": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 37,
        "endLine": 404,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 25,
        "startLine": 404
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 17,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 15
      }
    },
    "394": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 36,
        "endLine": 405,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 405
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 490,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 478
      }
    },
    "395": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 33,
        "endLine": 489,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 489
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 531,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 499
      }
    },
    "396": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 37,
        "endLine": 404,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 25,
        "startLine": 404
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 17,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 15
      }
    },
    "397": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 36,
        "endLine": 405,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 405
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 490,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 478
      }
    },
    "398": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 33,
        "endLine": 489,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 489
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 531,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 499
      }
    },
    "399": {
      "callCodeLocation": {
        "codeHash": "0xb7d84205eaaf83ce7b3940c6beaad6d22790255e34a9a2b486aa8cdfff118fe6",
        "endColumn": 50,
        "endLine": 45,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 16,
        "startLine": 45
      },
      "defCodeLocation": {
        "codeHash": "0xb7d84205eaaf83ce7b3940c6beaad6d22790255e34a9a2b486aa8cdfff118fe6",
        "endColumn": 6,
        "endLine": 65,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 48
      }
    },
    "42": {
      "callCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 39,
        "endLine": 530,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 14,
        "startLine": 530
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "43": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 73,
        "endLine": 732,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 30,
        "startLine": 732
      },
      "defCodeLocation": {
        "codeHash": "0xb7d84205eaaf83ce7b3940c6beaad6d22790255e34a9a2b486aa8cdfff118fe6",
        "endColumn": 70,
        "endLine": 17,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 17
      }
    },
    "45": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 65,
        "endLine": 712,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 47,
        "startLine": 712
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 339,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 335
      }
    },
    "47": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 56,
        "endLine": 735,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 13,
        "startLine": 735
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 393,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 391
      }
    },
    "49": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 64,
        "endLine": 719,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 13,
        "startLine": 719
      },
      "defCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 6,
        "endLine": 484,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 456
      }
    },
    "55": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 100,
        "endLine": 342,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 45,
        "startLine": 342
      },
      "defCodeLocation": {
        "codeHash": "0xb7d84205eaaf83ce7b3940c6beaad6d22790255e34a9a2b486aa8cdfff118fe6",
        "endColumn": 6,
        "endLine": 46,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 44
      }
    },
    "60": {
      "callCodeLocation": {
        "codeHash": "0xb7d84205eaaf83ce7b3940c6beaad6d22790255e34a9a2b486aa8cdfff118fe6",
        "endColumn": 32,
        "endLine": 62,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 9,
        "startLine": 62
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "61": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 60,
        "endLine": 470,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 20,
        "startLine": 470
      },
      "defCodeLocation": {
        "codeHash": "0xb7d84205eaaf83ce7b3940c6beaad6d22790255e34a9a2b486aa8cdfff118fe6",
        "endColumn": 70,
        "endLine": 17,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 17
      }
    },
    "63": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 60,
        "endLine": 471,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 20,
        "startLine": 471
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 393,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 391
      }
    },
    "77": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 38,
        "endLine": 382,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 14,
        "startLine": 382
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "78": {
      "callCodeLocation": {
        "codeHash": "0x60e4bcb14447615ab7c14fda2c2d70ca4191570e8841c75618e627c8f72662f8",
        "endColumn": 80,
        "endLine": 483,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 14,
        "startLine": 483
      },
      "defCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      }
    },
    "8": {
      "callCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      },
      "defCodeLocation": {
        "codeHash": "0x99ea26e2648e9e8fa051a7b9ff232edb02fba7c5f85511d6bdb66d29e92c5b5a",
        "endColumn": 6,
        "endLine": 393,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 391
      }
    },
    "80": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 56,
        "endLine": 735,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 13,
        "startLine": 735
      },
      "defCodeLocation": {
        "codeHash": "0xb7d84205eaaf83ce7b3940c6beaad6d22790255e34a9a2b486aa8cdfff118fe6",
        "endColumn": 70,
        "endLine": 17,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 17
      }
    },
    "82": {
      "callCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      },
      "defCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 6,
        "endLine": 103,
        "fileIndex": 2,
        "sourced": true,
        "startColumn": 5,
        "startLine": 101
      }
    },
    "84": {
      "callCodeLocation": {
        "codeHash": "",
        "endColumn": 0,
        "endLine": 0,
        "fileIndex": 0,
        "sourced": false,
        "startColumn": 0,
        "startLine": 0
      },
      "defCodeLocation": {
        "codeHash": "0xc2be4f894c1c91337f977f51694ecd95489fb2a9b55b45a6a33990e32029a3fe",
        "endColumn": 6,
        "endLine": 332,
        "fileIndex": 14,
        "sourced": true,
        "startColumn": 5,
        "startLine": 325
      }
    },
    "88": {
      "callCodeLocation": {
        "codeHash": "0xc2be4f894c1c91337f977f51694ecd95489fb2a9b55b45a6a33990e32029a3fe",
        "endColumn": 14,
        "endLine": 481,
        "fileIndex": 14,
        "sourced": true,
        "startColumn": 13,
        "startLine": 474
      },
      "defCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 6,
        "endLine": 738,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 5,
        "startLine": 722
      }
    },
    "89": {
      "callCodeLocation": {
        "codeHash": "0x69aef35de7236f9ae83edadff736f01ea40edd8919b2e73d87dea5d3255b8c3e",
        "endColumn": 108,
        "endLine": 21,
        "fileIndex": 0,
        "sourced": true,
        "startColumn": 45,
        "startLine": 21
      },
      "defCodeLocation": {
        "codeHash": "0x67b3aa9d362bb698531cd515e2c989ade0f8bd060f67f64e4f157c8fcac82c71",
        "endColumn": 6,
        "endLine": 163,
        "fileIndex": 2,
        "sourced": true,
        "startColumn": 5,
        "startLine": 158
      }
    }
  }
}